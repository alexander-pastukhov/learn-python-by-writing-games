[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn Python by Writing Games",
    "section": "",
    "text": "Introduction\nThis book will teach you programming. Hopefully, it will do so in a fun way because if there is something more satisfying than playing a video game then it is creating one. Although it is written for the course called “Python for social and experimental psychology”, my main aim is not to teach you Python per se. Python is a fantastic tool (more on this later) but it is just one of many programming languages that exist. My ultimate goal is to help you to develop general programming skills, which do not depend on a specific programming language, and make sure that you form good habits that will make your code clear, easy to read, and easy to maintain. That last part is crucial. Programming is not about writing code that works. That, obviously, must be true but it is only the minimal requirement. Programming is about writing a clear and easy-to-read code that others and, even more importantly, you-two-weeks later can understand.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#goal-of-the-book",
    "href": "index.html#goal-of-the-book",
    "title": "Learn Python by Writing Games",
    "section": "Goal of the book",
    "text": "Goal of the book\nThe goal is for you to be able to program a sophisticated experiment that can have multiple blocks and trials, various conditions, complicated visual presentation, automatic logging of data and exception handling. If this sound ambitious, it is but we will proceed in small steps in the process you will learn\n\nCore Python concepts including\n\nvariables and constants\nimmutable data types such as integers, floats, strings, logical values, and tuples\nmutable types such as lists and dictionaries\nfunctions\ncontrol structures such as if-else conditional statements and loops\nobject-oriented programming including concepts of inheritance, duck-typing, and mixing\nexceptions\nfile operations\n\nPsychoPy: this is not core Python but it is a prime library for psychophysical experiments and you will learn key tools that are required for programming an experiment.\nGood programming style including\n\nWriting clear code in iterative manner\nReading (your own) code\nDocumenting your code\nDebugging your program in VS Code\n\n\nI have tried to present concepts within the context that requires them and, therefore, best explain and presents their typical usage scenarios. This means that material is spread around and is presented in the need-to-now basis. For example, the concept of lists is presented first but operations on them are presented in the later chapter both because we only need this later and to keep your feeling of being overwhelmed to within reason. This makes this book harder to use as a reference (there are excellent references out where, starting with official Python documentation) but the hope is that by giving you bite-sized chunks of new information, it will make it easier to understand the material and integrate it with whatever you already know.\nSame “distributed” logic applies to exercises. Rather than being listed at the end of each chapter, they are embedded in the text and you should do them at that time point. A lot of them are designed to clarify concepts that were presented before them by using illustrative examples, so doing them immediately would be most helpful. Same goes for coding practice, although in that case, you can read the entire material to get a “bird’s eye view” of the entire program and then read the text again, doing the coding practice.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Learn Python by Writing Games",
    "section": "Prerequisites",
    "text": "Prerequisites\nThe material assumes no foreknowledge of Python or programming from the reader. Its purpose is to gradually build up your knowledge and allow you to create more and more complex games.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#why-games",
    "href": "index.html#why-games",
    "title": "Learn Python by Writing Games",
    "section": "Why games?",
    "text": "Why games?\nThe actual purpose of this course is to teach psychology and social studies students how to program experiments. That is what the real research is about. However, there is little practical difference between the two. The basic ingredients are the same and, arguably, experiments are just boring games. And, be assured, if you can program a game, you can certainly program an experiment.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#why-should-a-psychologist-learn-programming",
    "href": "index.html#why-should-a-psychologist-learn-programming",
    "title": "Learn Python by Writing Games",
    "section": "Why should a psychologist learn programming?",
    "text": "Why should a psychologist learn programming?\nWhy should a psychologist, who is interested in people, learn how to program computers? The most obvious answer is that this is a useful skill. Being able to program gives you freedom to create an experiment that answers your research question, not an experiment that can be implemented given constraints of your software.\nMore importantly, at least from my point of view, learning how to program changes the way you think in general. People are smart but computers are dumb1. When you explain your experiment or travel plans to somebody, you can be fairly vague, make a minor mistake, even skip certain parts. People are smart so they will fill in the missing information with their knowledge, spot and correct a mistake, ask you for more information, and can improvise on their own once they encounter something that you have not covered. Computers are dumb, so you must be precise, you cannot have gray areas, you cannot leave anything to “it will figure it out once it happens” (it won’t). My personal experience, corroborated by psychologists who learned programming, is that it makes you realize just how vague and imprecise people can be without realizing it (and without you realizing this as well). Programming forces you to be precise and thorough, to plan ahead for any eventuality there might be. And this is a very useful skill by itself as it can be applied to any activity that requires planning be that an experimental design or travel arrangements.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Learn Python by Writing Games",
    "section": "Why Python?",
    "text": "Why Python?\nThere are many ways to create an experiment for psychological research. You can use drag-and-drop systems either commercial like Presentation, Experiment Builder or free like PsychoPy Bulder interface. They have a much shallower learning curve, so you can start creating and running your experiments faster. However, the simplicity of their use has a price: They are fairly limited in which stimuli you can use and how you can control the presentation schedule, conditions, feedback, etc. Typically, they allow you to extend them by programming the desired behavior but you do need to know how to program to do this (knowing Python supercharges your PsychoPy experiments). Thus, I think that while these systems, in particular PsychoPy, are great tools to quickly bang a simple experiment together, they are most useful if you understand how they create the underlying code and how you would program it yourself. Then, you will not be limited by the software, as you know you can program something the default drag-and-drop won’t allow. At the same time, you can always opt in, if drag-and-drop is sufficient but faster or use a mix of the two approaches. At the end, it is about having options and creative freedom to program an experiment that will answer your research question, not an experiment that your software allows you to program.\nWe will learn programming in Python, which is a great language that combines simple and clear syntax with power and ability to tackle almost any problem. In this seminar, we will concentrate on desktop experiments but you can use it for online experiments (oTree and PsychoPy), scientific programming (NumPy and SciPy), data analysis (pandas), machine learning (scikit-learn), deep learning (keras), website programming (django), computer vision (OpenCV), etc. Thus, Python is one of the most versatile programming tools that you can use for all stages of your research or work. And, Python is free, so you do not need to worry whether you or your future employer will be able to afford license fees (a very real problem, if you use Matlab).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#seminar-specific-information",
    "href": "index.html#seminar-specific-information",
    "title": "Learn Python by Writing Games",
    "section": "Seminar-specific information",
    "text": "Seminar-specific information\nThis is a material for Python for social and experimental psychology seminar as taught by me at the University of Bamberg. Each chapter covers a single game, introducing necessary ideas and is accompanied by exercises that you need to complete and submit. To pass the seminar, you will need to complete all assignments, i.e., write all the games. You do not need to complete or provide correct solutions for all the exercises to pass the course and information on how the points for exercises will be converted to an actual grade (if you need one) or “pass” will be available during the seminar.\nThe material is structured, so that each chapter or chapter section typically correspond to a single meeting. However, we are all different, so work at your own pace, read the material and submit assignments independently. I will provide detailed feedback for each assignment and you will have an opportunity to address issues and resubmit again with no loss of points. Note that my feedback will cover not only the actual problems with the code but the way you implemented the solution and how clean and well-documented your code is. Remember, our task is not just to learn how to program a working game but how to write a nice clear easy-to-read-and-maintain code2.\nVery important: Do not hesitate to ask questions. If I feel that you missed the information in the material, I will point you to the exact location. If you are confused, I’ll gently prod you with questions so that you will solve your own problem. If you need more information, I’ll supply it. If you simply want to know more, ask and I’ll explain why things are the way they are or suggest what to read. If I feel that you should be able to solve the issue without my help, I’ll tell you so (although, I would still probably ask a few hinting questions).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#about-the-material",
    "href": "index.html#about-the-material",
    "title": "Learn Python by Writing Games",
    "section": "About the material",
    "text": "About the material\nThis material is free to use and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives V4.0 International License.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Learn Python by Writing Games",
    "section": "",
    "text": "This was written before large language models arrived but is still true when it comes to programming.↩︎\nGood habits! Form good habits! Thank you for reading this subliminal message.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "001-software.html",
    "href": "001-software.html",
    "title": "Software",
    "section": "",
    "text": "PsychoPy\nIf you are using Windows, download and install Standalone PsychoPy version. Use whatever the latest (and greatest) PsychoPy version is suggested to you (PsychoPy 2024.2.3 using Python 3.10 as of time of writing) and follow instructions.\nIf you are using Mac or Linux, installing PsychoPy via pip or Anaconda are your options. Please follow up-to-date instructions.",
    "crumbs": [
      "Software"
    ]
  },
  {
    "objectID": "001-software.html#install-vs-code",
    "href": "001-software.html#install-vs-code",
    "title": "Software",
    "section": "VS Code",
    "text": "VS Code\nVisual Studio Code is a free lightweight open-source editor with strong support for Python. Download the installer for your platform and follow the instructions.\nNext, follow Getting Started with Python in VS Code tutorial. If you are using Windows and the standalone PsychoPy installation, skip the Install a Python interpreter section, as you already have Python installation bundled with PsychoPy. This is the interpreter that you should use in the Select a Python interpreter section. In my case the path is C:\\Program Files\\PsychoPy\\python.exe.\nInstall and enable a linter, software that highlights syntactical and stylistic problems in your Python source code. Follow the manual at VS Code website.",
    "crumbs": [
      "Software"
    ]
  },
  {
    "objectID": "001-software.html#jupyter-notebooks",
    "href": "001-software.html#jupyter-notebooks",
    "title": "Software",
    "section": "Jupyter Notebooks",
    "text": "Jupyter Notebooks\nJupyter Notebooks offer a very convenient way to mix text, figure and code in a single document. They also make it easy to play with various small snippets in parallel without running scripts. We will rely on them for our first chapter and for an occasional exercises or code testing later on. There are two way you can use them: 1) in VS Code using Jupyter extension, 2) in your browser using classical interface.\n\nJupyter Notebooks in VS Code\nFollow the manual on how to install Jupyter package and use notebooks in VS Code.\n\n\nJupyter Notebooks in Anaconda\nThe simplest way to use Jupyter Notebooks along with a lot of other useful data science tools is via Anaconda toolkit. However, note that this will introduce a second Python distribution to your system. This, in turn, could lead to some confusion when working with scripts in VS Code if you accidentally have Anaconda interpreter active instead of the PsychoPy one. Do not panic, follow Select a Python interpreter instructions and make sure that you have PsychoPy interpreter as the active one.\nOtherwise, download and install Anaconda. The website has an excellent Getting started section.",
    "crumbs": [
      "Software"
    ]
  },
  {
    "objectID": "001-software.html#files-folder",
    "href": "001-software.html#files-folder",
    "title": "Software",
    "section": "Keeping things tidy",
    "text": "Keeping things tidy\nBefore we start, I suggest that you create a folder called games-with-python (or something along these lines). If you opted to use Jupyter Notebooks via Anaconda, you should create it in your user folder because this is where Anaconda would expects to find them. Then, create a new subfolder for each chapter / game. For the seminar, you would need to zip and upload a folder with all the files.",
    "crumbs": [
      "Software"
    ]
  },
  {
    "objectID": "001-software.html#footnotes",
    "href": "001-software.html#footnotes",
    "title": "Software",
    "section": "",
    "text": "If you are part of the seminar, ask me whenever you have problems or are unsure about how to proceeed↩︎",
    "crumbs": [
      "Software"
    ]
  },
  {
    "objectID": "002-programming-tips.html",
    "href": "002-programming-tips.html",
    "title": "Programming tips and tricks",
    "section": "",
    "text": "Writing the code",
    "crumbs": [
      "Programming tips and tricks"
    ]
  },
  {
    "objectID": "002-programming-tips.html#writing-tips",
    "href": "002-programming-tips.html#writing-tips",
    "title": "Programming tips and tricks",
    "section": "",
    "text": "Use a linter\nLinter is a program that analyses your code style and highlights any issues it finds: spaces where should be none, no spaces where should be some, wrong names, overly long lines, etc. These do not affect how the code runs but following linter’s advice results in a consistent standard if boring-looking2 Python code. Try to address all the problems that the linter raised. However, use your better judgment because sometimes lines that are longer than linter would prefer are more readable than two shorter ones. Similarly, a “bad” variable name by linter standards can be a meaningful name for a psychologist. Remember, your code is for people, not for the linter.\n\n\nDocument your code\nEvery time you create a new file: document it and update the documentation whenever you add/change/delete new functions or classes. Every time your create a new function: document it. New class: document it. New constant: unless it is super clear from the name alone, document it. You will learn a NumPy way of doing this in the book.\nI cannot stress how important documenting your code is. VS Code (an editor that we will use) is smart enough to parse NumPy docstring, so it will show this help to you whenever you use your own functions (helps you to help you!). More importantly, writing documentation forces you to think and formulate (in human language!) what the function or class is doing, what type the arguments / attributes / methods are, what is the range of valid values, what are the defaults, what should a function return, etc. More often than not, you will realize that you have overlooked some important detail that may not be apparent from the code itself.\n\n\nAdd some air\nSeparate chunks of code with some empty lines. Think paragraphs in the normal text. You wouldn’t want your book to be a single paragraph nightmare? Put a comment before each chunk that explains what it does but not how it does it. E.g., in our typical PsychoPy-based game there will be a point when we draw all stimuli and update the window. That is a nice self-contained chunk that can be described as # drawing all stimuli. The code provides details on what exactly is drawn, what is the drawing order, etc. But that single comment will help you to understand what this chunk is about and whether it is relevant for you at the moment. Same goes for # processing key presses or # checking gameover conditions, etc. But be careful and make sure that the comment describes the code correctly. E.g., if the comment says # drawing all stimuli where should be no stimuli-drawing code anywhere else and no code that does something else!\n\n\nWrite your code one teeny-tiny step a time\nYour motto should be “slow but steady”. This is the way I will guide you through the games. Always start with a something extremely simple like a static rectangle or image. Make sure it works. Add a minor functionality: Change in color, position, another rectangle, storing it as an attribute, etc. Make sure it works. Never go to the next step unless you fully understand what your current code is doing and you are 100% certain that it behaves as it should. And I mean 100% seriously! If you have even a shadow of a doubt, check again. Otherwise, that shadow will grow and make you progressively uncertain about your code. This tortoise-speed approach may feel silly and overly slow but it is still faster than writing a large chunk of code and then trying to make it work. It is much easier to solve simple problems one at a time than a lot of them simultaneously.\n\n\nThere is nothing wrong with StackOverflow\nYes, you can always try to find a solution to your problem on StackOverflow3. I do it all the time! However, you should use the provided solution only if you understand it! Do not copy-paste the code that seems to solve a problem like yours. If you do that and you are lucky, it might work. Or, again if you are lucky, it won’t work in an obvious manner. But if you are not so lucky, it will (sometimes) work incorrectly in a subtle way. And, since you did not really know what the code was doing when you pasted it, you will be even more confused. So use StackOverflow as a source of knowledge, not as a source of copy-pastable code!",
    "crumbs": [
      "Programming tips and tricks"
    ]
  },
  {
    "objectID": "002-programming-tips.html#reading-tips",
    "href": "002-programming-tips.html#reading-tips",
    "title": "Programming tips and tricks",
    "section": "Reading the code",
    "text": "Reading the code\nReading code is easy because computers are dumb and you are smart. This means that instructions you give the computer must necessarily be very simple and, therefore, are very easy to understand for a human. Reading code is also hard because computers are dumb and you are smart. You are so smart that you don’t even need to read the entire code to understand what it is doing, you just read the key bits and fill in the gaps. Unfortunately, this means that you will tend to read over mistakes. This is not unique to programming, if you ever proofraed a text, you now how hard it is to find tipos. Your brain corrects them on the fly using the context and you read the word as it should be, not as it is actually written4.\nMy experience with programming in general and on this seminar in particular is that most problems you get stuck with are simple to the point of being dumb and obvious in retrospect5. Do not despair! It is not you, but just a consequence of how wonderfully your brain is wired for pattern-recognition. Below are several suggestions that could help you to make reading code more robust.\n\nThink like a computer\nRead the code line-by-line and “execute” it the way the compute would. Use pen-and-paper to keep the track of variables. Trace which chunks of code can be reached and when. Slow yourself down and make sure you understand each line and are able to keep track of the variables. Once you do that it will be easy to spot a mistake.\n\n\nPretend that you’ve never seen this code in your life\nAssume that you have no idea what the code is doing. As I wrote, quite often you literally do not see a mistake because your brain fills-in details and bends the reality to match your expectations6. You know what this chunk of code should be doing, so instead of reading it you skim through it and, unless it looks obviously terribly wrong, assume that it does what it should. Turning your expectations off is hard but is immensely helpful.\n\n\nDo not search only under the street lamp\nWhenever you are using some new code or need to implement something that feels complicated and your code does not work as it should, you will tend to assume that a problem is with the new fancy code. Simply because it is new, fancy, and complicated. But, in my experience, the error will typically hide in plain sight in the simpler “trivial” code nearby which you never properly look at because it is simple and trivial. Check everything, not just the places where you would expect to have made a mistake.\n\n\nUse the debugger\nIn the book, you will learn how to pause an execution of your game, so you can investigate its state. Use this knowledge! Put breakpoints and execute the code step-by-step. Check values of variables using “Watch” tab. Use debug console to check whether functions return results that they should. For complex conditions or mathematical formulas, split them into small bits, copy and execute these bits in the debug console and check whether numbers add up. Make sure that a code chunk checks out and then proceed to analyze the next one. Debugging is particularly helpful to identify the code that is not reached or reached at the wrong moment.",
    "crumbs": [
      "Programming tips and tricks"
    ]
  },
  {
    "objectID": "002-programming-tips.html#zen-of-python",
    "href": "002-programming-tips.html#zen-of-python",
    "title": "Programming tips and tricks",
    "section": "Zen of Python",
    "text": "Zen of Python\nI found Zen of Python to be good inspiration on how to approach programming.",
    "crumbs": [
      "Programming tips and tricks"
    ]
  },
  {
    "objectID": "002-programming-tips.html#footnotes",
    "href": "002-programming-tips.html#footnotes",
    "title": "Programming tips and tricks",
    "section": "",
    "text": "Happened to me more often than I dare to admit.↩︎\n“Boring is Good!”, see “The Hitman’s Bodyguard” movie.↩︎\nHowever, if you are doing the seminar, ask me first!↩︎\nTip: Read your text one sentence at a time starting from the back or read one random sentence at a time. This breaks the flow of the text and helps you concentrate on words rather than on the meaning and the story.↩︎\nHindsight is always 20/20!↩︎\nRecently, I spent half-an-hour trying to understand why two identical chunks of code give me different results. My son almost instantly found a difference (a missing comma in of the them) because for him it was just bunch of letters and numbers.↩︎",
    "crumbs": [
      "Programming tips and tricks"
    ]
  },
  {
    "objectID": "01-basics.html",
    "href": "01-basics.html",
    "title": "1  Python basics",
    "section": "",
    "text": "1.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#chapter-concepts",
    "href": "01-basics.html#chapter-concepts",
    "title": "1  Python basics",
    "section": "",
    "text": "Variables.\nConstants.\nBasic value types.\n[Print] things(#print).\nPutting values into strings.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#variables",
    "href": "01-basics.html#variables",
    "title": "1  Python basics",
    "section": "1.2 Variables",
    "text": "1.2 Variables\nThe first fundamental concept that we need to be acquainted with is variable. Variables are used to store information and you can think of it as a box with a name tag, so that you can put something into it. The name tag on that box is the name of the variable and its value what you store in it. For example, we can create a variable that stores the number of legs that a game character has. We begin with a number typical for a human being.\n\n\n\nVariable as a box\n\n\nIn Python, you would write\nnumber_of_legs = 2\nThe assignment statement above has very simple structure:\n&lt;variable-name&gt; = &lt;value&gt;\nVariable name (name tag on the box) should be meaningful, it can start with letters or _ and can contain letters, numbers, and _ symbol but not spaces, tabs, special characters, etc. Python recommends1 that you use snake_case (all lower-case, underscore for spaces) to format your variable names. The &lt;value&gt; on the right side is a more complex story, as it can be hard-coded (as in example above), computed using other variables or the same variable, returned by a function, etc.\nUsing variables means that you can concentrate what corresponding values mean rather than worrying about what these values are. For example, the next time you need to compute something based on number of character’s legs (e.g., how many pairs of shoes does a character need), you can compute it based on current value of number_of_legs variable rather than assume that it is 1.\n# BAD: why 1? Is it because the character has two legs or\n# because we issue one pair of shoes per character irrespective of\n# their actual number of legs?\npairs_of_shoes = 1\n\n# BETTER (but what if our character has only one leg?)\npairs_of_shoes = number_of_legs / 2\nVariables also give you flexibility. Their values can change during the program run: player’s score is increasing, number of lives decreasing, number of spells it can cast grows or falls depending on their use, etc. Yet, you can always use the value in the variable to perform necessary computations. For example, here is a slightly extended number_of_shoes example.\nnumber_of_legs = 2\n\n# ...\n# something happens and our character is turned into an octopus\nnumber_of_legs = 8\n# ...\n\n# the same code still works and we still can compute the correct number of pairs of shoes\npairs_of_shoes = number_of_legs / 2\nAs noted above, you can think about a variable as a labeled box you can store something in. That means that you can always “throw away” the old value and put something new. In case of variables, the “throwing away” part happens automatically, as a new value overwrites the old one. Check yourself, what will be final value of the variable in the code below?\nnumber_of_legs = 2\nnumber_of_legs = 5\nnumber_of_legs = 1\nnumber_of_legs\n\nDo exercise #1.\n\nNote that a variable (“a box with a name tag”) exists only after you assign something to it. So, the following code will generate a NameError, a Python’s way to tell that you it never heard of variable number_of_hands.\n\nnumber_of_legs = 2\nnumber_of_gloves = number_of_hands / 2\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 2\n      1 number_of_legs = 2\n----&gt; 2 number_of_gloves = number_of_hands / 2\n\nNameError: name 'number_of_hands' is not defined\n\n\n\nHowever, you can create a variable the does not hold any specific value by assigning None to it. None was added to the language specifically to mean no value or nothing.\nnumber_of_hands = None # variable exists now, but holds no particular value.\nAs you have already seen, you can compute a value instead of specifying it. What would be the answer here?\nnumber_of_legs = 2 * 2\nnumber_of_legs = 7 - 2\nnumber_of_legs\n\nDo exercise #2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#assignments-are-not-equations",
    "href": "01-basics.html#assignments-are-not-equations",
    "title": "1  Python basics",
    "section": "1.3 Assignments are not equations!",
    "text": "1.3 Assignments are not equations!\nVery important: although assignments look like mathematical equations, they are not equations! They follow a very important rule that you must keep in mind when understanding assignments: the right side of an expression is evaluated first until the final value is computed, then and only then that final value is assigned to the variable specified on the left side (put into the box). What this means is that you can use the same variable on both sides! Let’s take a look at this code:\nx = 2\ny = 5\nx = x + y - 4\nWhat happens when computer evaluates the last line? First, it takes current values of all variables (2 for x and 5 for y) and puts them into the expression. After that internal step, the expression looks like\nx = 2 + 5 - 4\nThen, it computes the expression on the right side and, once the computation is completed, stores that new value in x\nx = 3\n\nDo exercise #3 to make sure you understand this.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#constants",
    "href": "01-basics.html#constants",
    "title": "1  Python basics",
    "section": "1.4 Constants",
    "text": "1.4 Constants\nAlthough the real power of variables is that you can change their value, you should use them even if the value remains constant throughout the program. There are no true constants in Python, rather an agreement that their names should be all UPPER_CASE. Accordingly, when you see SUCH_A_VARIABLE you know that you should not change its value. Technically, this is just a recommendation, as no one can stop you from modifying value of a CONSTANT. However, much of Python’s ease-of-use comes from such agreements (such as a snake_case convention above). We will encounter more of such agreements later, for example, when learning about objects.\nTaking all this into account, if number of legs stays constant throughout the game, you should highlight that constancy and write\nNUMBER_OF_LEGS = 2\nI strongly recommend using constants and avoid hardcoding values. First, if you have several identical values that mean different things (2 legs, 2 eyes, 2 ears, 2 vehicles per character, etc.), seeing a 2 in the code will not tell you what does this 2 mean (the legs? the ears? the score multiplier?). You can, of course, figure it out based on the code that uses this number but you could spare yourself that extra effort and use a properly named constant instead. Then, you just read its name and the meaning of the value becomes apparent and it is the meaning not the actual value that you are mostly interested in. Second, if you decide to permanently change that value (say, our main character is now a tripod), when using a constant means you have only one place to worry about, the rest of the code stays as is. If you hard-coded that number, you are in for an exciting2 and definitely long search-and-replace throughout the entire code.\n\nDo exercise #4.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#value-types",
    "href": "01-basics.html#value-types",
    "title": "1  Python basics",
    "section": "1.5 Value types",
    "text": "1.5 Value types\nSo far, we only used integer numeric values (1, 2, 5, 1000…). Although, Python supports many different value types, at first we will concentrate on a small subset of them:\n\ninteger numbers, we already used, e.g. -1, 100000, 42.\nfloat numbers that can take any real value, e.g. 42.0, 3.14159265359, 2.71828.\nstrings that can store text. The text is enclosed between either paired quotes \"some text\" or apostrophes 'some text'. This means that you can use quotes or apostrophes inside the string, as long as its is enclosed by the alternative. E.g., \"students' homework\" (enclosed in \", apostrophe ' inside) or '\"All generalizations are false, including this one.\" Mark Twain' (quotation enclosed by apostrophes). There is much much more to strings and we will cover that material throughout the course.\nlogical / Boolean values that are either True or False.\n\nWhen using a variable it is important that you know what type of value it stores and this is mostly on you. In some cases, Python will raise an error, if you try doing a computation using incompatible value types. In other cases, Python will automatically convert values between certain types, e.g. any integer value is also a real value, so conversion from 1 to 1.0 is mostly trivial and automatic. However, in other cases you may need to use explicit conversion. Go to exercise #5 and try guessing which code will run and which will throw an error due to incompatible types?\n5 + 2.0\n'5' + 2\n'5' + '2'\n'5' + True\n5 + True\n\nDo exercise #5.\n\nSurprised by the last one? This is because internally, True is also 1 and False is 0!\nYou can explicitly convert from one type to another using special functions. For example, to turn a number or a logical value into a string, you simply write str(&lt;value&gt;). In examples below, what would be the result?\nstr(10 / 2)\nstr(2.5 + True)\nstr(True)\n\nDo exercise #6.\n\nSimilarly, you can convert to a logical/Boolean variable using bool(&lt;value&gt;) function. The rules are simple, for numeric values 0 is False, any other non-zero value is converted to True. For string, an empty string '' is evaluated to False and non-empty string is converted to True. What would be the output in the examples below?\nbool(-10)\nbool(0.0)\n\nsecret_message = ''\nbool(secret_message)\n\nbool('False')\n\nDo exercise #7.\n\nConverting to integer or float numbers using, respectively, int(&lt;value&gt;) and float(&lt;value&gt;) is trickier. The simplest case is from logical to integer/float, as True gives you int(True) is 1 and float(True) is 1.0 and False gives you 0/0.0. When converting from float to integer, Python simply drops the fractional part (it does not do proper rounding!). When converting a string, it must be a valid number of the corresponding type or the error is generated. E.g., you can convert a string like \"123\" to an integer or a float but this won’t work for \"a123\". Moreover, you can convert \"123.4\" to floating-point number but not to an integer, as it has fractional part in it. Given all this, which cells would work and what output would they produce?\nfloat(False)\nint(-3.3)\nfloat(\"67.8\")\nint(\"123+3\")\n\nDo exercise #8.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#print",
    "href": "01-basics.html#print",
    "title": "1  Python basics",
    "section": "1.6 Printing output",
    "text": "1.6 Printing output\nTo print the value, you need to use print() function (we will talk about functions in general later). In the simplest case, you pass the value and it will be printed out.\n\nprint(5)\n\n5\n\n\nor\n\nprint(\"five\")\n\nfive\n\n\nOf course, you already know about the variables, so rather than putting a value directly, you can pass a variable instead and its value will be printed out.\n\nnumber_of_pancakes = 10\nprint(number_of_pancakes)\n\n10\n\n\nor\n\nbreakfast = \"pancakes\"\nprint(breakfast)\n\npancakes\n\n\nYou can also pass more than one value/variable to the print function and all values will be printed one after another. For example, if we want to tell the user what did I had for breakfast, we can do\n\nbreakfast = \"pancakes\"\nnumber_of_items = 10\nprint(breakfast, number_of_items)\n\npancakes 10\n\n\nWhat will be printed by the code below?\ndinner = \"steak\"\ncount = 4\ndesert = \"cupcakes\"\n\nprint(count, dinner, count, desert)\n\nDo exercise #9.\n\nHowever, you probably would want to be more explicit, when you print out the information. For example, imagine you have these three variables:\n\nmeal = \"breakfast\"\ndish = \"pancakes\"\ncount = 10\n\nYou could, of course do print(meal, dish, count) but it would be nicer to print “I had 10 pancakes for breakfast”, where items in bold would be the inserted variables’ values. For this, we need to use string formatting. Please note that the string formatting is not specific to printing, you can create a new string value via formatting and store it in a variable without printing it out or print it out without storing it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#string-formatting",
    "href": "01-basics.html#string-formatting",
    "title": "1  Python basics",
    "section": "1.7 String formatting",
    "text": "1.7 String formatting\nA great resource on string formatting in Python is pyformat.info. As Python constantly evolves, it now has more than one way to format strings. Below, I will introduce the “old” format that is based on classic string formatting used in sprintf function in C, Matlab, R, and many other programming languages. It is somewhat less flexible than newer ones but for simple tasks the difference is negligible. Knowing the old format is useful because of its generality. If you want to learn alternatives, read at the link above.\nThe general call is \"a string with formatting\"%(tuple of values to be used during formatting). You will learn about tuples later. For now, assume that it is just a comma-separated list of values enclosed in round brackets: (1, 2, 3).\nIn \"a string with formatting\", you specify where you want to put the value via % symbol that is followed by an optional formatting info and the required symbol that defines the type of the value. The type symbols are\n\ns for string\nd for an integer\nf for a float value\ng for an “optimally” printed float value, so that scientific notation is used for large values (e.g., 10e5 instead of 100000).\n\nHere is an example of formatting a string using an integer:\n\nprint(\"I had %d pancakes for breakfast\"%(10))\n\nI had 10 pancakes for breakfast\n\n\nYou are not limited to a single value that you can put into a string. You can specify more locations via % but you must make sure that you pass the right number of values in the right order. Before running it, can you figure out which call will actually work (and what will be the output) and which will produce an error?\nprint('I had %d pancakes and either %d  or %d steaks for dinner'%(2))\nprint('I had %d pancakes and %d steaks for dinner'%(7, 10))\nprint('I had %d pancakes and %d steaks for dinner'%(1, 7, 10))\n\nDo exercise #10.\n\nAs noted above, in case of real values you have two options: %f and %g. The latter uses scientific notation (e.g. 1e10 for 10000000000) to make a representation more compact.\n\nDo exercise #11 to get a better feeling for the difference.\n\nThese is much more to formatting and you can read about it at pyformat.info. However, these basics are sufficient for us to start programming our first game in the next chapter.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "01-basics.html#footnotes",
    "href": "01-basics.html#footnotes",
    "title": "1  Python basics",
    "section": "",
    "text": "Well, actually, insists.↩︎\nnot really↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html",
    "href": "02-guess-the-number-single-round.html",
    "title": "2  Guess the Number: a single round edition",
    "section": "",
    "text": "2.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#chapter-concepts",
    "href": "02-guess-the-number-single-round.html#chapter-concepts",
    "title": "2  Guess the Number: a single round edition",
    "section": "",
    "text": "Documenting code.\nDebugging code.\nGetting input from a user.\nUsing comparison in conditional statements.\nUsing indentation to group statements together.\nUsing Python libraries.\nGenerating random numbers.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#the-game",
    "href": "02-guess-the-number-single-round.html#the-game",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.2 The Game",
    "text": "2.2 The Game\nWe will program a game in which one participant (computer) picks a number within a certain range (say, between 1 and 10) and the other participant (human player) is trying to guess it. After every guess of the human, the computer responds whether the actual number is lower than a guess, higher than a guess, or matches it. The game is over when the player correctly guesses the number or (in the later version of the game) runs out of attempts.\nOur first version will allow just one attempt and the overall game algorithm will look like this:\n\ncomputer generates a random number between 1 and 10\nprints it out for debugging purposes\nprompts user to enter a guess\ncompares two numbers and print outs the outcome: “My number is lower”, “My number is higher”, or “Spot on!”",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#lets-pick-a-number",
    "href": "02-guess-the-number-single-round.html#lets-pick-a-number",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.3 Let’s pick a number",
    "text": "2.3 Let’s pick a number\nLet us start by implementing just the first two steps of the program. First, create a variable holding a number that computer “picked”. We will name it number_picked (you can use some other meaningful name as well but it might be easier if we all stick to the same name). To make things simpler at the beginning, we will hard-code an arbitrary number between 1 and 10 (pick the one you like). Then, let us print it out, so that we know the number ourselves3. Use string formatting to make things user-friendly, e.g., print out something like “The number I’ve picked is …”. You should be able to do this using the knowledge from the previous chapter. Your code should be a two-liner:\n# 1. create variable and set its value\n# 2. print out the value\nTry out this two-liner in a Jupyter Notebook (create an empty notebook just for that). Once you are happy with it, copy-paste the code into code01.py and read on to learn how to document and run it.\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#documenting-your-code",
    "href": "02-guess-the-number-single-round.html#documenting-your-code",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.4 Documenting your code",
    "text": "2.4 Documenting your code\nNow that you have your first file with Python program, you should document it. Documenting a two-lines long and simple program may feel silly but it should be an automatic thing. Later on you will find yourself using several lines of comments to document a single line function. Again, it is not about the code that works, it is about the code you can understand. In a sense, it is better to have a clean well-documented program that currently does not work correctly than an undocumented spaghetti code that does. You can fix and update the former, but maintaining or updating the latter…\nIn Python, you have two ways to write comments: multiline and single line\n'''A \nmultiline \ncomment\n'''\n\n#  A single line comment.\nUse multiline comments to write documentation for individual files, functions, classes, methods, etc. You will learn how to format this documentation Numpy docstring style, once you learn about functions. In our case, you should start your code01.py file with a multiline comment that briefly describes what program it contains. Minimally, you should write that this is a Guess a Number game. It is probably a good idea to sketch out what the game is about.\nUse single line comments to explain what happens in a particular code block. You do not need to comment every line and you should not replicate the code in human language. A comment should be about what is going on not how. You already have a single chunk of code, so document it with a single sentence.\n\nDocument code01.py file.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#debugging",
    "href": "02-guess-the-number-single-round.html#debugging",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.5 Running and debugging your game in VS Code",
    "text": "2.5 Running and debugging your game in VS Code\nNow that we have a two-lines-long program, we can run it and already start learning how to debug it. Yes, our current program is probably to simple to require actual debugging but it is also simple enough to make understanding debugging easier as well. And debugging is a crucial skill that turns a running program from a black box into something transparent and easy4 to understand. Below I will describe how to debug in VS Code but you might want to consult an official manual in case things have changed in the meantime.\nThere are two ways to run a Python program in VS Code. First, you can use the “Run Python File in Terminal” play button on the right. This runs your program without a debugger, so you should use it only for the actual runs of the finalized code. Still, you can try running it and see whether it prints out what it should.\n\n\n\nRunning code without a debugger.\n\n\nThe alternative is the debugging tab, the one with a little bug on top of the run button. If you select it, it will show “Run and Debug”. Click on the button and it will offer various choices for different kinds of Python projects and frameworks. For our intents and purposes, we will only need “Python File: Debug the currently active Python file”. Click on that and it will execute your code (should run exactly the same way as with the other button).\n\n\n\nSelecting debugging configuration.\n\n\nYou probably do not want to click through Debugging tab → Run and Debug button → Pick configuration all the time. A better way is to configure it once and for all and then use F5 key to run your code. First, click on “create a launch.json file” and select the “Python File: Debug the currently active Python file” again. You will see a new launch.json file appearing in the editor that should look like this:\n\n\n\nDebug configuration in launch.json file.\n\n\nThat’s it! VS Code created a configuration for you. Now you can close launch.json file and run your program with a simple press of F5 button. Try it! Again, it should work just like before, so why did we go through all this trouble? Because debugger will pause an execution of your code whenever it encounters a problem, giving you a chance to examine variables, run snippets of code, etc. In contrast, running python file in terminal (the first option) will only print an error message and exit the program. Moreover, you can use breakpoints to pause the program at any line, which gives you an opportunity to examine your code at any location that you need.\nYou enable breakpoints by clicking to the left of the line number that you are interested in. Here, I’ve clicked on line 6 and you can see a red dot that indicates an active breakpoint.\n\n\n\nActive breakpoint.\n\n\nIf I now run the code via F5, the program will stop at that line before executing it.\n\n\n\nProgram paused at the breakpoint.\n\n\nThis gives me a chance to see what value my number_picked variable has. It is already listed in local variables (top left). But I also added it to list of watched variables (Watch, left middle) and I also looked at its value in the Debug Console (bottom tab) that allows me to execute any Python code while my program is paused. Do the same and explore these different ways yourself. For example, see how you can compute number_picked + 1 or number_picked * number_picked in the Watch tab and in Debug Console.\nOnce you are done examining the current state of the program, you have six buttons at the top to decide what to do next (hover over them to see hints). They are, from left to right\n\nContinue (F5): resume the program.\nStep Over (F10): executes the code without going into functions (this and two following options will become clearer once you learn about writing functions).\nStep Into the code (F11)\nStep Out of the code (Shift+F11).\nRestart the program (Ctrl+Shift+F5).\nStop the program (Shift+F5).\n\nTo better understand how this works, stop the program (Shift+F5) and put an additional breakpoint on the first line of your code (line #5 in my program, the other lines are comments or are empty). Run the program again via F5 and it will pause at that very first line. Can you figure out the value of variable number_picked now?\nThe answer is “no” because that variable does not exist yet. Remember, the program pauses before executing the line. Use F10 to step through the code line by line to see how the variable appears and the information gets printed out.\nThis debugging exercise may not have been necessary to solve problems with your current code but it showed how to do that in the future. Do not hesitate to put a breakpoint to pause the program and check that reality (i.e., actual values of variables) matches your expectations. Use the stepping through the code to slow things down to watch and ponder.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#input-function",
    "href": "02-guess-the-number-single-round.html#input-function",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.6 Asking a player for a guess",
    "text": "2.6 Asking a player for a guess\nIt takes two to play the Guess the Number game. The computer did its part by picking a number, now we need to ask a player to enter their guess. For this, we will use input() function.\nA function is an isolated code that accepts (optional) inputs, performs an action, and, optionally, returns a value (output). This allows both to split the code into smaller chunks that are easier to maintain and to reuse the same code. You already used print() function to print things out, and str(), bool(), int() and float() functions to convert values. For print() input is an arbitrary number of values (even none, try this in Jupiter Notebook!), its action is to print things out, but it returns nothing (no output). float() function takes (somewhat surprisingly) zero or one value as input (try giving it none or more than one in Jupiter Notebook as see the difference), attempts to convert given value to float (throwing an error, if it cannot do it), and returns a float value as an output.\nSimilar input → action → output scheme holds for the input(prompt). It takes an optional prompt string as input. Then it prints the prompt message and waits for a user to enter a string until they press Enter. It then returns this string value. The latter bit about string is important, because in our game we need a player to enter an integer not a string. For a moment, let us assume that the input is always a valid integer number, so type only valid integers when testing the program! This way we can convert it to an integer without extra checks (will add them in the future) and assign this value to a new variable called guess. Thus, you need to add a single line assignment statement with guess variable on the left side and call to input() function on the right side (think of a nice prompt message) wrapped by (inside of) the type-conversion to integer via int(). Test this code but, again, only enter valid integers, so that the conversion works without an error.\n\nUpdate your code01.py.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#if-statement",
    "href": "02-guess-the-number-single-round.html#if-statement",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.7 Conditional if statement",
    "text": "2.7 Conditional if statement\nNow we have two numbers: One that computer picked (number_picked) and one that the has player entered (guess). We need to compare them to provide correct output message. For this, we will use conditional if statement:\nif some_condition_is_true:\n    # do something\nelif some_other_condition_is_true:\n    # do something else\nelif yet_another_condition_is_true:\n    # do yet something else\nelse:\n    # do something only if all conditions above are false.\nOnly the if part is required, whereas elif (short for “else, if”) and else are optional. Thus you can do something, only if a condition is true:\nif some_condition_is_true:\n    # do something, but OTHERWISE DO NOT DO ANYTHING \n    # and continue with code execution\n  \n# some code that is executed after the if-statement,\n# irrespective of whether the condition was true or not.\nBefore we can use conditional statements in our game, you need to understand (1) the conditions themselves and (2) use of indentation as a mean of grouping statements together.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#comparisons",
    "href": "02-guess-the-number-single-round.html#comparisons",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.8 Conditions and comparisons",
    "text": "2.8 Conditions and comparisons\nCondition is any expression that can be evaluated to see whether it is True or False. A straightforward example of such expression are comparisons expressed in human language as: Is today Thursday? Is the answer (equal to) 42? Is it raining and I have an umbrella? We will concentrate on comparisons like that for a moment but later you will see that in Python any expression is either True or False, even when it does not look like a comparison5.\nFor the comparison, you can use the following operators:\n\n“A is equal B” is written as A == B.\n“A is not equal B” is written as A != B.\n“A is greater than B” and “A is smaller than B” are, respectively, A &gt; B and A &lt; B.\n“A is greater than or equal to B” and “A is smaller than or equal to B” are, respectively, A &gt;= B and A &lt;= B (please note the order of symbols as =&gt; and =&lt; will produce an error).\n\n\nGo to exercise #1 to solve some comparisons.\n\nNote that Python also has an is operator that may look identical to == (e.g., x == 2 looks equivalent to x is 2). Moreover, in some cases it also works the same way. However, there is a subtle difference: == checks whether values are identical, whereas is checks whether objects (that “hold” values) are identical. You need to understand classes and objects before you can appreciate this difference, so for now just keep in mind that you should only use == (I will explicitly mentioned when is is needed).\nYou can invert the logical value using not operator, as not True is False and not False is True. This means that A != B is the same as not A == B and, correspondingly, A == B is not A != B. To see how that works, consider both cases when A is indeed equal B and when it is not.\n\nIf A is equal B then A == B evaluates to True. The A != B is then False, so not A != B → not False → True.\nIf A is not equal B then A == B evaluates to False. The A != B is then True, so not A != B → not True → False.\n\n\nGo to exercise #2 to explore this inversion yourself.\n\nYou can also combine several comparisons using and and/or6 or operators. As in human language, and means that both parts must be true: True and True → True but True and False → False, False and True → False, and False and False → False. Same holds if you have more than two conditions/comparisons linked via and: All of them must be true. In case of or only one of the statements must be true, e.g. True or True → True, True or False → True, False or True → True, but False or False → False. Again, for more than two comparisons/conditions at least one of them should be true for the entire expression to be true.\n\nDo exercises #3 and #4.\n\nSubtle but important point: conditions are evaluated from left to right until the whole expression is resolved one way or another. This means that if the first expression in a and is False, the second one (the rest of them) is never evaluated. I.e., if first and second expressions both need to be True and you know that first expression already is false, the whole expression will be False in any case. This means that in the code below there will be no error, even though evaluating int(\"e123\") alone would raise a ValueError.\n\n2 * 2 == 5 and int(\"e123\") == 123\n\nFalse\n\n\nHowever, reverse the order, so that int(\"e123\") == 123 needs to be evaluated first and you get the error message\n\nint(\"e123\") == 123 and 2 * 2 == 4\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 int(\"e123\") == 123 and 2 * 2 == 4\n\nValueError: invalid literal for int() with base 10: 'e123'\n\n\n\nSimilarly, if any expression in or is True, you do not need to check the rest.\n\n2 * 2 == 4 or int(\"e123\") == 123\n\nTrue\n\n\nHowever, if the first condition is False, we do need to continue (and stumble into an error):\n\n2 * 2 == 5 or int(\"e123\") == 123\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 2 * 2 == 5 or int(\"e123\") == 123\n\nValueError: invalid literal for int() with base 10: 'e123'\n\n\n\n\nDo exercise #5.\n\nFinally, like in simple arithmetic, you can use brackets () to group conditions together. Thus a statement “I always eat chocolate but I eat spinach only when I am hungry” can be written as food == \"chocolate\" or (food == \"spinach\" and hungry). Here, the food == \"chocolate\" and food == \"spinach\" and hungry are evaluated independently, their values are substituted in their place and then the and condition is evaluated.\n\nDo exercise #6.\n\nFinal thought on comparisons: Do not hesitate to test them in Jupyter Notebook using various combinations of values or pause the program at the condition via a breakpoint and evaluate a comparison in Watch or Debug Console.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#indentation",
    "href": "02-guess-the-number-single-round.html#indentation",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.9 Grouping statements via indentation",
    "text": "2.9 Grouping statements via indentation\nLet us go back to a conditional if-statement. Take a look at following code example (and note an : at the end of the if some_condition_is_true:), in which statement #1 is executed only if some condition is true, whereas statement #2 is executed after that irrespective of the condition.\nif some_condition_is_true:\n    statement #1\nstatement #2 \nBoth statements #1 and #2 appear after the if-statement, so how does Python know that the first one is executed only if condition is true but the other one always runs? The answer is indentation: The 4 (four!) spaces that are automatically added whenever you press Tab in VS Code and removed whenever you press Shift+Tab. The indentation puts statement #1 inside the if-statement. Thus, indentation shows whether statements belong to the same group and must be executed one after another (same indentation level for if and statement #2) or are inside conditional statement, loop, function, class, etc. (statement #1). For more complex code that will have, for example, an if-statement inside an if-statement inside a loop, you will express this by adding more levels of indentation. E.g.\n# some statements outside of the loop (0 indentation)\nwhile game_is_not_over: # (0 indentation)\n    # statements inside of the loop \n    if key_pressed: # (indentation of 4)\n        # inside loop and if-statement \n        if key == \"Space\": # (indentation of 8)\n            # inside the loop, and if-statement, and another if-statement\n            jump() # (indentation of 12)\n        else: # (indentation of 4)\n            # inside the loop, and if-statement, and else part of another if-statement\n            stand() # (indentation of 12)\n    \n    # statements inside of the loop but outside of the outermost if-statement\n    print(key) # (indentation of 4)\n    \n# some statements outside of the loop (0 indentation)\nPay very close attention to the indentation as it determines which statements are executed together! A wrong indentation level is unfortunately a very common mistake.\n\nDo exercise #7.\n\nThe if and ifelse statements are evaluated until one of them turns out to be True. After that any following ifelse and else statements are simply ignored.\n\nDo exercise #8.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#checking-the-answer",
    "href": "02-guess-the-number-single-round.html#checking-the-answer",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.10 Checking the answer",
    "text": "2.10 Checking the answer\nNow you have all necessary tools to finish the first version of our game. Add a conditional statements to your code01.py, so that\n\nif the computer pick is smaller than player’s guess, it will print \"My number is lower!\"\nif the computer pick is larger than player’s guess, it will print \"My number is higher!\"\nif two numbers are identical, it will print \"Spot on!\"\n\nFirst, save a copy of your original code into code02.py and then add the comparison and printing.\n\nExtend your program with the comparison in code02.py\n\nTest that your code works. Again, use breakpoints if you need to better understand the control flow and check whether comparisons work the way you expect.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#using-libraries",
    "href": "02-guess-the-number-single-round.html#using-libraries",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.11 Using libraries",
    "text": "2.11 Using libraries\nOur game is “feature-complete”: computer picks a number, player makes a guess, computer responds appropriately. However, currently we are playing for both sides. Lets make computer pick a random number itself. For this we need to use randint(a, b) function. It is a part of any Python distribution, so you would have it even if you install a vanilla Python distribution instead of using one from PsychoPy. However, you cannot use it straightaway like you did with print() or input(). Type randint(1, 3) in your Jupyter Notebook and observe NameError: name ‘randint’ is not defined.\nThe reason for this is that Python has an awful lot of functions and loading them all at the same time would clog the memory with things you never intended to use. Instead, they are packaged into libraries, so that you can import only functions (or libraries) that you actually need for your program. You import them via an import statement that should go to the top of your file (but below the comment about the file content). There are several ways you can import libraries. First, you can import an entire library (such as random library that has function randint() that we need) and then use its functions as &lt;library&gt;.&lt;function&gt;. For randint this would be\nimport random\n\ncomputer_pick = random.randint(1, 5)\nI would suggest this as a preferred way of using libraries as it forces you to explicitly mention the name of the library when calling a function, i.e. random.randint() instead of just randint(). This may not look important with just one imported library but even in a modestly-sized project you will import many libraries, so figuring out which library the function belongs to will be tricky. Even more importantly, different libraries may have functions with the same name. In this case, the function you are using will come from the last library you imported. But you may not realize this and this is a sort of mistake that is really hard to track down. Thus, unless you have a very good reason to do otherwise, always import the entire library and use library. notation!\nAnother and less explicit option is to import only some functions and use them without the library. prefix. You can import more than one function by listing them all\nfrom random import randint, randrange\n\ncomputer_pick = randint(1, 5)\nYou can also rename a library or a function while importing it via as. In short, you should not do this as using a different name for a library or a function would make it harder for others (and even for future-you) to understand your code. However, there are some “standard” renaming patterns that are used universally and which you are likely to encounter.\n# this is a standard way to import these two libraries\nimport numpy as np\nimport pandas as pd\n\nnp.abs(-1)\n\n# you can rename individual functions as well, if you really have to (but, please, don't!)\nfrom random import randint as random_integer\n\ncomputer_pick = random_integer(1, 5)\nFinally, there is a very bad way to import functions from a library: from random import *. The asterisk means that you want to import all functions from the library and you want to call them by their names without random. prefix. Never, never, never7 do this! This fills your environment with functions that you may not be aware of, potentially overwriting some other functions, creating conflicts, etc. Never ever! I am showing you this only because you will, at some point, see a code that uses this approach and you might think that this is a good idea. It is a terrible idea! Import the library, not the functions, so you can explicitly show which library you are relying on when calling a function. Always remember the Zen of Python: “Explicit is better than implicit.”",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#picking-a-number-randomly",
    "href": "02-guess-the-number-single-round.html#picking-a-number-randomly",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.12 Picking a number randomly",
    "text": "2.12 Picking a number randomly\nNow that you know how to import a library, we can use randint() function. For this, save a copy of your previous code into code03.py. Import the library and use randint() to generate a random number between 1 and 10. Read the documentation on randint() to understand how to use it. Reading manuals is a necessary part of programming, so this is a good point to start practicing.\nOnce you implemented this in code03.py, run it several times to check that computer does pick different random values. Again, use breakpoints if you want to double-check what is going on.\n\nPut your code into code03.py.\n\nCongratulations, you just programmed your first computer game! Yes, it is very simple but it has key ingredients: a random decision by computer, user input, and feedback. Next time, you will learn about loops to allow for multiple attempts and will start writing functions to make your code modular and reliable. In the meantime, let us solidify your knowledge by programming yet another game!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#one-armed-bandit-a-single-round-edition",
    "href": "02-guess-the-number-single-round.html#one-armed-bandit-a-single-round-edition",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.13 One-armed bandit (a single round edition)",
    "text": "2.13 One-armed bandit (a single round edition)\nYou know everything you need to program a simple version of an “one-armed bandit” game. Here is the game logic:\n\nImport random library, so you could use randint function\nGenerate three random integers (say, between 1 and 5) and store them in three variables slot1, slot2, and slot3.\nPrint out the numbers, use string formatting to make it look nice.\nIn addition,\n\nif all three values are the same, print \"Three of a kind!\".\nIf only two numbers match, print \"Pair!\".\nDo not print anything, if all numbers are different.\n\n\nDo not forget to document the new code04.py file and feel free to use breakpoints to debug it.\n\nPut your code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#submitting-for-the-seminar",
    "href": "02-guess-the-number-single-round.html#submitting-for-the-seminar",
    "title": "2  Guess the Number: a single round edition",
    "section": "2.14 Submitting for the seminar",
    "text": "2.14 Submitting for the seminar\nFor the seminar, submit a zipped folder with exercise notebook and all four programs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "02-guess-the-number-single-round.html#footnotes",
    "href": "02-guess-the-number-single-round.html#footnotes",
    "title": "2  Guess the Number: a single round edition",
    "section": "",
    "text": "You can “Save as…” the previous code to avoid copy-pasting things by hand.↩︎\nI recommend using 01 instead of 1, as it will ensure consistent file sorting in your file manager↩︎\nOf course, we know it because we hard-coded it, but that won’t be the case when computer will generate it randomly, so let us plan for the future↩︎\nOr, at least, easier.↩︎\nThis is because you can convert any value to a logical one via bool() function that you learned about the last time and so any value is (converted to) either True or False.↩︎\npun intended↩︎\nDid I already say never? Never!↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guess the Number: a single round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html",
    "href": "03-guess-the-number-multi-round.html",
    "title": "3  Guess the Number: a multi round edition",
    "section": "",
    "text": "3.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#chapter-concepts",
    "href": "03-guess-the-number-multi-round.html#chapter-concepts",
    "title": "3  Guess the Number: a multi round edition",
    "section": "",
    "text": "Repeating code using while loop.\nMaking in emergency exit from a loop.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#while-loop",
    "href": "03-guess-the-number-multi-round.html#while-loop",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.2 While loop",
    "text": "3.2 While loop\nIf you want to repeat something, you need to use loops. There are two types of loops: while loop, which is repeated while a condition is true, and for loop that iterates over items (we will use it later).\nThe basic structure of a while loop is\n# statements before the loop\n\nwhile &lt;condition&gt;:\n    # statements inside are executed\n    # repeatedly for as long as\n    # the condition is True\n    \n# statements after the loop\nThe &lt;condition&gt; here is any expression that is evaluated to be either True or False, just like in an if...elif...else conditional statement. Also, the same indentations rules determine which code is inside the loop and which outside.\n\nDo exercise #1.\n\nLet us use while loop to allow the player to keep guessing until they finally get it right. You can copy-paste the code you programmed during the last seminar or could redo it from scratch (I would strongly recommend you doing the latter!). The overall program structure should be the following\n# import random library so you can use randint function\n\n# generated a random number and store in number_picked variable\n# get player input, convert it to an integer, and store in guess variable\n\n# while players guess is not equal to the value the computer picked:\n    # print out \"my number is smaller\" or \"my number is larger\" using if-else statement\n    # get player input, convert it to an integer, and store in guess variable\n    \n# print \"Spot on!\" \n# (because if we got here that means guess is equal to the computer's pick)\n\nPut your code into code01.py.\n\nDo not forget to document the file and use breakpoints and step overs to explore the program flow.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#counting-attempts",
    "href": "03-guess-the-number-multi-round.html#counting-attempts",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.3 Counting attempts",
    "text": "3.3 Counting attempts\nNow let us add a variable that will count a total number of attempts by the player. For this, create a new variable (call it attempts or something similar) before the loop and initialize it 1 (because the first attempt is before the player enter the loop). Add 1 to it every time the player enters a guess. After the loop, expand the \"Spot on!\" message by adding information about the number of attempts. Use string formatting to make things look nice, e.g., \"Spot on, and you needed just 5 attempts!\". Check that the number of attempts your required matches the number of attempts reported by the program!\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#break",
    "href": "03-guess-the-number-multi-round.html#break",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.4 Breaking (and exiting)",
    "text": "3.4 Breaking (and exiting)\nCode inside the while loop is executed repeatedly while the condition is True and, importantly, all of code inside is executed before the condition is evaluated again. However, sometimes you may need to abort sooner without executing the remaining code. For this, Python has a break statement that causes the program to exit the loop immediately without executing the rest of the code inside the loop, so that the program continues with the code after the loop.\n# this code runs before the loop\n\nwhile &lt;some_condition&gt;:\n  # this code runs on every iteration\n  \n    if &lt;some_other_condition&gt;:\n        break\n  \n  # this code runs on every iteration but not when you break out of the loop\n\n# this code runs after the loop\n\nDo exercise #2 to build your intuition.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#limiting-number-of-attempts-via-break",
    "href": "03-guess-the-number-multi-round.html#limiting-number-of-attempts-via-break",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.5 Limiting number of attempts via break",
    "text": "3.5 Limiting number of attempts via break\nLet’s put the player under some pressure! Decide on maximal number of attempts you allow and stores it as a CONSTANT. Pick an appropriate name (e.g. MAX_ATTEMPTS) and REMEMBER, ALL CAPITAL LETTERS for a constant name! Now, use break to quit the while loop, if the current attempt number is greater than MAX_ATTEMPTS. Think about when (within the code inside the loop) you should check this.\n\nPut your code into code03.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#correct-end-of-game-message",
    "href": "03-guess-the-number-multi-round.html#correct-end-of-game-message",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.6 Correct end-of-game message",
    "text": "3.6 Correct end-of-game message\nLet us update the final message. Currently it says “Spot on…” because we assumed that program exited the loop only if the player gave a correct answer. With limited attempts that is not necessarily the case. Now there are two reasons why it exited the while loop:\n\nThe player answered correctly\nThe player ran out of attempts.\n\nUse if-else conditional statement to print out an appropriate message. E.g., print \"Better luck next time!\", if the player lost (ran out of attempts).\n\nPut your code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#limiting-number-of-attempts-without-a-break",
    "href": "03-guess-the-number-multi-round.html#limiting-number-of-attempts-without-a-break",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.7 Limiting number of attempts without a break",
    "text": "3.7 Limiting number of attempts without a break\nAlthough it was my idea to add the break statement, you should use it sparingly. Without break there is a single place in the code that you need to check to understand when the program will exit the loop: the condition. However, if you add a break, you now have two places that need to be examined. And every additional break keeps adding to that. This does not mean that you should avoid them at all costs! You should use them, if this makes the code easier to understand. But always check if a modified condition could also do the trick.\nLet us try exactly that. Modify your code to work without the break statement. You need a more complicated condition for your while loop. so that it repeats while player’s guess is incorrect and the number of attempts is still less than the maximally allowed. Test that your code works both when you win and when you lose.\n\nPut your code into code05.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#show-remaining-attempts",
    "href": "03-guess-the-number-multi-round.html#show-remaining-attempts",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.8 Show remaining attempts",
    "text": "3.8 Show remaining attempts\nIt is all about the user interface! Modify the input prompt message to include a number of remaining attempts. E.g. \"Please enter the guess, you have X attempts remaining\".\n\nPut your code into code06.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#guess-the-number-repeat-game",
    "href": "03-guess-the-number-multi-round.html#guess-the-number-repeat-game",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.9 Repeating the game",
    "text": "3.9 Repeating the game\nLet us give an option for the player to play again. This means putting all the current code inside of another while loop (this is called nested loops) that is repeated for as long as the player wants to keep playing. The code should look as follows:\n# import random library so you can use randint function\n\n# define MAX_ATTEMPTS\n\n# define a variable called \"want_to_play\" and set to True\n# while the player still wants to play\n  \n  # your current working game code goes here\n  \n  # ask user whether via input function. E.g. \"Want to play again? Y/N\"\n  # want_to_play should be True if user input is equal to \"Y\" or \"y\"\n  \n# very final message, e.g. \"Thank you for playing the game!\"\nPay extra attention to indentations to group the code properly!\n\nPut your code into code07.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#you-do-not-need-a-comparison-if-you-already-have-the-value",
    "href": "03-guess-the-number-multi-round.html#you-do-not-need-a-comparison-if-you-already-have-the-value",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.10 You do not need a comparison, if you already have the value",
    "text": "3.10 You do not need a comparison, if you already have the value\nIn your updated code, you have want_to_play variable that is either True or False. It is used in the loop that repeats while its value is True. Sometimes, people write want_to_play == True to express that. While it is technically correct and will certainly work correctly, it is also redundant. Since want_to_play can only be True or False this comparison turns into True == True (which is of course True) or False == True (which is False). So comparing either value to True produces exactly the same value. Thus, you can just write while want_to_play: and use the logical value directly.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#best-score",
    "href": "03-guess-the-number-multi-round.html#best-score",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.11 Best score",
    "text": "3.11 Best score\nA “proper” game typically keeps the track of players’ performance. Let us record a fewest number of attempts that the player needed to guess the number. For this, create a new variable fewest_attempts and set it to MAX_ATTEMPTS (this is as bad as the player can be). Think, where do you need to create it. You should update it after each game round. Add the information about “Best so far” into the round-over message.\n\nPut your code into code08.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#counting-game-rounds",
    "href": "03-guess-the-number-multi-round.html#counting-game-rounds",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.12 Counting game rounds",
    "text": "3.12 Counting game rounds\nLet us count how many times the player played the game. The idea and implementation is the same as with counting the attempts. Create a new variable, initialize it to 0, increment by 1 whenever a new round starts. Include the total number of games played into the very final message, e.g. “Thank you for playing the game X times!”\n\nPut your code into code09.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#multi-round-one-armed-bandit",
    "href": "03-guess-the-number-multi-round.html#multi-round-one-armed-bandit",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.13 Multi round one-armed bandit",
    "text": "3.13 Multi round one-armed bandit\nAt the end of the previous chapter, you have programmed a single round one-armed bandit game. You already know everything you need to implement a multiple round version and its structure is similar (but simpler) than of the multi-round guess-the-number game that you just implemented.\nLet player start with an initial pot of money, say 10 coins. Playing each round costs 1 coin, getting three of a kind pays off 10 coins, while getting a pair pays off 2 coins (you can change payoffs as you see fit). On each round:\n\nTake one coin from the pot (price for playing the game).\nRoll the dice (you already implemented that).\nTell the player about the outcome (you implemented that as well).\nAdd coins to the pot, if necessary.\nPrint out the amount of coins left in pot.\nAsk the player where they want to continue.\n\nSpecial case, once the player runs out of coins, the game is definitely over.\n\nPut your code into code10.py.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "03-guess-the-number-multi-round.html#wrap-up",
    "href": "03-guess-the-number-multi-round.html#wrap-up",
    "title": "3  Guess the Number: a multi round edition",
    "section": "3.14 Wrap up",
    "text": "3.14 Wrap up\nMost excellent, you now have two proper working computer games with game rounds, limited attempts, best score, and what not! Zip the folder and submit.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guess the Number: a multi round edition</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html",
    "href": "04-guess-the-number-ai.html",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "",
    "text": "4.1 Chapter concepts.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#chapter-concepts.",
    "href": "04-guess-the-number-ai.html#chapter-concepts.",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "",
    "text": "Writing your own functions.\nUnderstanding variable scopes.\nAdopting standard ways to document your code.\nUsing your own libraries.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#guess-the-number-players-response",
    "href": "04-guess-the-number-ai.html#guess-the-number-players-response",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.2 Player’s response",
    "text": "4.2 Player’s response\nLet us warm up by writing a code that will allow a player to respond to computer’s guess. Recall that there are just three options: your number is greater, smaller, or equal to a computer’s guess. I would suggest using &gt;, &lt;, and = symbols to communicate this. You need to write the code that will prompt a player for their response until they enter one of these symbols. I.e., the prompt for input should be repeated if they enter anything else. Thus, you definitely need to use the input([prompt]) and a while loop. Think of a useful and informative prompt message for this. Test that it works. Using breakpoints might be very useful here.\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#function",
    "href": "04-guess-the-number-ai.html#function",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.3 Functions",
    "text": "4.3 Functions\nYou already now how to use functions, now it is turn for you to learn more about why you should care. The purpose of a function is to isolate certain code that performs a single computation making it testable and reusable. Let us go through the last sentence bit by bit using examples.\n\n4.3.1 Function performs a single computation\nI already told you that reading code is easy because every action has to be spelled-out for computers in a simple and clear way. However, a lot of simple things can be very overwhelming and confusing. Think about the final code for the previous seminar: we had two loops with conditional statements nested inside. Add a few more of those and you have so many branches to trace, you never be quite sure what will happen. This is because our cognition and working memory, which you use to trace all branches, are limited to just about four items3.\nThus, a function should perform one computation / action that is conceptually clear and those purpose should be understood directly from its name or, at most, from a single sentence that describes it4. The name of a function should typically be a verb because function is about performing an action. If you need more than once sentence to explain what function does, you should consider splitting the code further. This does not mean that entire description / documentation must fit into a single sentence. The full description can be lengthy, particularly if underlying computation is complex and there are many parameters to consider. However, these are optional details that tell the reader how the function is doing its job or how its behavior can be modified. Still, they should be able to understand what the job is just from the name or from a single sentence. I am repeating myself and stressing this so much because conceptually simple single-job functions are a foundation of a clear robust reusable code. And future-you will be very grateful that it has to work with easy-to-understand isolated reliable code you wrote.\n\n\n4.3.2 Function isolates code from the rest of the program\nIsolation means that your code runs in a separate scope where the only things that exist are function arguments (limited number of values you pass to it from outside with fixed meaning) and local variables that you define inside the function. You have no access to variables defined in the outside script5 or to variables defined inside of other functions. Conversely, neither global script nor other functions have access to variables and values that you use inside. This means that you only need to study the code inside the function to understand how it works. Accordingly, when you write the code it should be independent of any global context the function can be used in. The isolation is both practical (no run-time access to variables from outside means fewer chances that things go terribly wrong) and conceptual (no further context is required to understand the code).\n\n\n4.3.3 Function makes code easier to test\nYou can build even moderately complex programs only if you can be certain what individual chunks of code are doing under every possible condition. Do they produce the correct results? Do the fail clearly and raise a correct error, if the inputs are wrong? Do they use defaults when required? However, testing all chunks together means running extreme number of runs as you need to test all possible combinations of conditions for one chunk given all possible conditions for other chunk, etc. Functions make your life much easier. Because they have a single point of entry, fixed number of parameters, a single return value, and are isolated (see above), you can test them one at a time independent of other functions and the rest of the code. This is called unit testing and it is a heavy use of automatic unit testing6 that ensures reliable code for absolute majority of programs and apps that you use7.\n\n\n4.3.4 Function makes code reusable\nSometimes, this is given as a primary reason to use functions. Turning code into a function means that you can call the function instead of copy-pasting the code. The latter approach is a terrible idea as it means that you have to maintain the same code at many places and you might not be even sure in just how many. This is a problem even if a code is extremely simple. Here, we define a standard way to compute an initial by taking the first symbol from a string (you will learn about indexing and slicing later). The code is as simple as it gets.\n...\ninitial = \"test\"[0]\n...\ninitial_for_file = filename[0]\n...\ninitial_for_website = first_name[0]\n...\nImagine that you decided to change it and use first two symbols. Again, the computation is not complicated, use just replace [0] with [:2]. But you have to do it for all the code that does this computation. And you cannot use Replace All option because sometimes you might use the first element for some other purposes. And when you edit the code, you are bound to forget about some locations (I do it all the time) making things even less consistent and more confusing. Turning code into a function means you need to modify and test at just one location. Here is the original code implemented via a function.\ndef generate_initial(full_string):\n    \"\"\"Generate an initial using first symbol.\n    \n    Parameters\n    ----------\n    full_string : str\n    \n    Returns\n    ----------\n    str\n        single symbol\n    \"\"\"\n    return full_string[0]\n\n...\ninitial = generate_initial(\"test\")\n...\ninitial_for_file = generate_initial(filename)\n...\ninitial_for_website = generate_initial(first_name)\n...\nand here is the “alternative” initial computation. Note that the code that uses the function stays the same\ndef generate_initial(full_string):\n    \"\"\"Generate an initial using first TWO symbols.\n    \n    Parameters\n    ----------\n    full_string : str\n    \n    Returns\n    ----------\n    str\n        two symbols long\n    \"\"\"\n    return full_string[:2]\n\n...\ninitial = generate_initial(\"test\")\n...\ninitial_for_file = generate_initial(filename)\n...\ninitial_for_website = generate_initial(first_name)\n...\nThus, turning the code into a function is particularly useful when the reused code is complex but it pays off even if computation is as simple and trivial as in example above. With a function you have a single code chunk to worry about and you can be sure that the same computation is performed whenever you call the function (and that these are not several copies of the code that might or might not be identical).\nNote that I put reusable code as the last and the least reason to use functions. This is because the other three reasons are far more important. Having a conceptually clear isolated and testable code is advantageous even if you call this function only once. It still makes code easier to understand and to test and helps you to reduce its complexity by replacing chunks of code with its meaning. Take a look at the example below. The first code takes the first symbol but this action (taking the first symbol) does not mean anything by itself, it is just a mechanical computation. It is only the original context initial_for_file = filename[0] or additional comments that give it its meaning. In contrast, calling a function called compute_initial tells you what is happening, as it disambiguates the purpose. I suspect that future-you is very pro-disambiguation and anti-confusion.\nif filename[0] == \"A\":\n    ...\n    \nif compute_initial(filename) == \"A\":\n    ...",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#functions-in-python",
    "href": "04-guess-the-number-ai.html#functions-in-python",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.4 Functions in Python",
    "text": "4.4 Functions in Python\n\n4.4.1 Defining a function in Python\nA function in Python looks like this (note the indentation and : at the end of the first line)\ndef &lt;function name&gt;(param1, param2, ...):\n    some internal computation\n    if somecondition:\n        return some value\n    return some other value\nThe parameters are optional, so is the return value. Thus, the minimal function would be\ndef minimal_function():\n    pass # pass means \"do nothing\"\nYou must define your function (once!) before calling it (one or more times). Thus, you should create functions before the code that uses it.\ndef do_something():\n    \"\"\"\n    This is a function called \"do_something\". It actually does nothing.\n    It requires no input and returns no value.\n    \"\"\"\n    return\n    \ndef another_function():\n    ...\n    # We call it in another function.\n    do_something()\n    ...\n\n# This is a function call (we use this function)\ndo_something()\n\n# And we use it again!\ndo_something()\n\n# And again but via another_function call\nanother_function()\n\nDo exercise #1.\n\nYou must also keep in mind that redefining a function (or defining a technically different function that has the same name) overwrites the original definition, so that only the latest version of it is retained and can be used.\n\nDo exercise #2.\n\nAlthough example in the exercise makes the problem easy to spot, in a large code that spans multiple files and uses various libraries, solving the same problem may not be so straightforward!\n\n\n4.4.2 Function arguments\nSome functions may not need arguments (also called parameters), as they perform a fixed action:\ndef ping():\n    \"\"\"\n    Machine that goes \"ping!\"\n    \"\"\"\n    print(\"ping!\")\nHowever, you may need to pass information to the function via arguments in order to influence how the function performs its action. In Python, you simply list arguments within the round brackets after the function name (there are more bells and whistles but we will keep it simple for now). For example, we could write a function that computes and prints person’s age given two parameters 1) their birth year, 2) current year:\ndef print_age(birth_year, current_year):\n    \"\"\"\n    Print age given birth year and current year.\n    \n    Parameters\n    ----------\n    birth_year : int\n    current_year : int\n    \"\"\"\n    print(current_year - birth_year)\nIt is a very good idea to give meaningful names to functions, parameters, and variables. The following code will produce exactly the same result but understanding why and what for it is doing what it is doing would be much harder (so always use meaningful names!):\ndef x(a, b):\n    print(b - a)\nWhen calling a function, you must pass the correct number of parameters and pass them in a correct order, another reason for a function arguments to have meaningful names8.\n\nDo exercise #3.\n\nWhen you call a function, values you pass to the function are assigned to the parameters and they are used as local variables (more on local bit later). However, it does not matter how you came up with this values, whether they were in a variable, hard-coded, or returned by another function. If you are using numeric, logical, or string values (immutable types), you can assume that any link to the original variable or function that produced it is gone (we’ll deal with mutable types, like lists, later). Thus, when writing a function or reading its code, you just assume that it has been set to some value during the call and you can ignore the context in which this call was made\n# hardcoded\nprint_age(1976, 2020)\n\n# using values from variables\ni_was_born = 1976\ntoday_is = 2023\nprint_age(i_was_born, today_is)\n\n# using value from a function\ndef get_current_year():\n    return 2023\n\nprint_age(1976, get_current_year())\n\n\n4.4.3 Functions’ returned value (output)\nYour function may perform an action without returning any value to the caller (this is what out print_age function was doing). However, you may need to return the value instead. For example, to make things more general, we might want write a new function called compute_age that returns the age instead of printing it (we can always print it ourselves).\ndef compute_age(birth_year, current_year):\n    \"\"\"\n    Computes age given birth year and current year.\n\n    Parameters\n    ----------\n    birth_year : int\n    current_year : int\n    \n    Returns\n    ----------\n    int\n        age\n    \"\"\"\n    return current_year - birth_year\nNote that even if a function returns the value, it is retained only if it is actually used (stored in a variable, used as a value, etc.). Thus, just calling it will not by itself store the returned value anywhere!\n\nDo exercise #4.\n\n\n\n4.4.4 Scopes (for immutable values)\nAs we have discussed above, turning code into a function isolates it, so makes it run in it own scope. In Python, each variable exists in a scope it has been defined in. If it was defined in the global script, it exists in that global scope as a global variable. However, it is not accessible (at least not without special effort via a global operator) from within a function. Conversely, function’s parameters and any variables defined inside a function, exists and are accessible only inside that function. It is fully invisible for the outside world and cannot be accessed from a global script or from another function. Conversely, any changes you make to the function parameter or local variable have no effect on the outside world.\nThe purpose of scopes is to isolate individual code segments from each other, so that modifying variables within one scope has no effect on all other scopes. This means that when writing or debugging the code, you do not need to worry about code in other scopes and concentrate only on the code you working on. Because scopes are isolated, they may have identically named variables that, however, have no relationship to each other as they exists in their own parallel universes9. Thus, if you want to know which value a variable has, you must look only within the scope and ignore all other scopes (even if the names match!).\n# this is variable `x` in the global scope\nx  = 5 \n\ndef f1():\n  # This is variable `x` in the scope of function f1\n  # It has the same name as the global variable but\n  # has no relation to it: many people are called Sasha \n  # but they are still different people. Whatever\n  # happens to `x` in f1, stays in f1's scope.\n  x = 3\n  \n  \ndef f2(x):\n  # This is parameter `x` in the scope of function f2.\n  # Again, no relation to other global or local variables.\n  # It is a completely separate object, it just happens to \n  # have the same name (again, just namesakes)\n  print(x)\n\nDo exercise #5.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#players-response-as-a-function",
    "href": "04-guess-the-number-ai.html#players-response-as-a-function",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.5 Player’s response as a function",
    "text": "4.5 Player’s response as a function\nLet us put all that theory about functions into practice. Use the code that you created to acquire player’s response and turn it into function. It should have no parameters (for now) and should return player’s response. I suggest that you call it input_response (or something along these lines). Test that the code works by calling this function for the main script.\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#debugging-a-function",
    "href": "04-guess-the-number-ai.html#debugging-a-function",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.6 Debugging a function",
    "text": "4.6 Debugging a function\nNow that you have your first function, you can make sense of three step over/step in/step out buttons that the debugger offers you. Copy-paste the following code in a separate file (call it test01.py, for example).\ndef f1(x, y):\n  return x / y\n  \ndef f2(x, y):\n  x = x + 5\n  y = y * 2\n  return f1(x, y)\n  \nz = f2(4, 2)\nprint(z)\nFirst, put a break point on the line in the main script that calls function f2(). Run the debugger via F5 and the program will pause at that line. If you now press F10 (step over), the program will go to the next line print(z). However, if you are to press F11 (step into) instead, the program will step into the function and go to x = x + 5 line. When inside the function, you have the same two choices we just looked at but also, you can press Shift+F11 to step out of the function. Here, the program will run all the code until you reach the next line outside of the function (you should end up at print(z) again). Experiment with putting breakpoints at various lines and stepping over/in/out to get a hang of these useful debugging tools.\nNow, put the breakpoint inside of f1() function and run the code via F5. Take a look at the left pane, you will see a Call Stack tab. While yellow highlighted line in the editor shows you where you currently are (should be inside the f1() function), the Call Stack shows you how did you get where. In this case it should show:\n\n\n\nf1\ntest01.py\n2:1\n\n\nf2\ntest01.py\n7:1\n\n\n&lt;module&gt;\ntest01.py\n9:1\n\n\n\nThe calls are stacked from bottom to top, so this means that a function was called in the main module in line 9, you ended up in function f2 in line 7, and then in function f1 and in line 2. Experiment with stepping in and out of functions while keeping an eye on this. You might not need this information frequently but could be useful in our later projects with multiple nested function calls.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#numpy-docstring",
    "href": "04-guess-the-number-ai.html#numpy-docstring",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.7 Documenting your function",
    "text": "4.7 Documenting your function\nWriting a function is only half the job. You need to document it! Remember, this is a good habit that makes your code easy to use and reuse. There are different ways to document the code but we will use NumPy docstring convention. Here is an example of such documented function\ndef generate_initial(full_string):\n    \"\"\"Generate an initial using first symbol.\n    \n    Parameters\n    ----------\n    full_string : str\n    \n    Returns\n    ----------\n    str\n        single symbol\n    \"\"\"\n    return full_string[0]\nTake the look at the manual and document the input_response function. You will not need the Parameters section as it currently accepts no inputs.\n\nUpdate your code in code02.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#using-prompt",
    "href": "04-guess-the-number-ai.html#using-prompt",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.8 Using prompt",
    "text": "4.8 Using prompt\nIn the future, we will be asking about a specific number that is a current guess by the computer, thus we cannot use a fixed prompt message. Modify the input_response function by adding a guess parameter. Then, modify the prompt that you used for the input() to include the value in that parameter. Update functions’ documentation. Test it by calling with different values for the guess parameter and seeing a different prompt for response.\n\nPut your code into code03.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#round-function",
    "href": "04-guess-the-number-ai.html#round-function",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.9 Splitting interval in the middle",
    "text": "4.9 Splitting interval in the middle\nLet us practice writing functions a bit more. Recall that the computer should use the middle of the interval as a guess. Create a function (let us call it split_interval() or something like that) that takes two parameters — lower_limit and upper_limit — and returns an integer that is closest to the middle of the interval. The only tricky part is how you convert a potentially float number (e.g, when you are trying to find it for the interval 1..10) to an integer. You can use function int() for that. However, read the documentation carefully, as it does not perform a proper rounding (what does it do? read the docs!). Thus, you should round() the number to the closest integer before converting it.\nWrite a function, document it, and test it by checking that numbers are correct.\n\nPut you split_interval() function and the testing code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#single-round",
    "href": "04-guess-the-number-ai.html#single-round",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.10 Single round",
    "text": "4.10 Single round\nYou have both functions that you need, so let us write the code to initialize the game and play a single round. The initialization boils down to creating two variables that correspond to the lower and upper limits of the game range (we used 1 to 10 so far, but you can always change that). Next, the computer should generate a guess (you have your split_interval() function for that) and ask the player about the guess (that is the input_response() function). Once you have the response (stored in a separate variable, think of the name yourself), update either upper or lower limit using an if..elif..else statement based on player’s response (if the player said that their number is higher, that means the new interval is from guess to upper_limit, and vice versa for when it is lower). Print out a joyous message, if computer’s guess was correct.\n\nPut both functions and the script code into code05.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#multiple-rounds",
    "href": "04-guess-the-number-ai.html#multiple-rounds",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.11 Multiple rounds",
    "text": "4.11 Multiple rounds\nExtend the game, so that the computer keeps guessing until it finally wins. You already know how to use the while loop, just think how you can use participant’s response as a loop condition variable. Also, think about the initial value of that variable and how to use it so you call input_response() only at one location.\n\nPut the updated code into code06.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#playing-again",
    "href": "04-guess-the-number-ai.html#playing-again",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.12 Playing again",
    "text": "4.12 Playing again\nModify the code, so that you can play this game several times. You already know how to do this and the only thing you need to consider is where exactly should you perform initialization before each game. As you already implemented that for the last game, you might be tempted to look how you did it or, even, copy-paste the code. However, I would recommend writing it from scratch. Remember, your aim is not to write a program but to learn how to do this and, therefore, the journey is more important than a destination.\n\nPut the updated code into code07.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#best-score",
    "href": "04-guess-the-number-ai.html#best-score",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.13 Best score",
    "text": "4.13 Best score\nAdd the code to count the number of attempts that the computer required in each round and report the best score (fewest number of attempts) after the game is over. You will need one variable to count the number of attempts and one to keep the best score. Again, try writing it without looking at your previous game.\n\nPut the updated code into code08.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#using-you-own-libraries",
    "href": "04-guess-the-number-ai.html#using-you-own-libraries",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.14 Using you own libraries",
    "text": "4.14 Using you own libraries\nYou already know how to use existing libraries but you can also create and use your own. Take the two functions that you developed and put them into a new file called utils.py (do not forget to put a multiline comment at the top of the file to remind you what is inside!) . Copy the remaining code (the global script) into code09.py. It will not work in its current state as it won’t find the two functions (try it to see the error message), so you need to import from your own utils module. Importing works exactly the same way as for other libraries. Note that even though your file is utils.py, the module name is utils (without the extension).\n\nPut function into utils.py, the remaining code into code09.py.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#keep-imports-tidy",
    "href": "04-guess-the-number-ai.html#keep-imports-tidy",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.15 Ordnung muss sein!",
    "text": "4.15 Ordnung muss sein!\nSo far, you only imported one library at most. However, as Python is highly modular, it is very common to have many imports in a single file. There are several rules that make it easier to track the imports. When you import libraries, all import statements should be at the top of your file and you should avoid putting them in random order. The recommended order is 1) system libraries, like os or random; 2) third-party libraries, like ]psychopy]{.filename}; 3) your project modules. And, within each section you should put the libraries alphabetically, so\nimport os\nimport random\nThis may not look particularly useful for our simple code but as your projects will grow, you will need to include more and more libraries. Keeping them in that order makes it easy to understand which libraries you use and which are non-standard. Alphabetic order means that you can quickly check whether a library is included, as you can quickly find the location where its import statement should appear.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#putting-video-into-videogames",
    "href": "04-guess-the-number-ai.html#putting-video-into-videogames",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "4.16 Putting video into videogames",
    "text": "4.16 Putting video into videogames\nSubmit your files and be ready for more excitement as we are moving onto “proper” videogames with PsychoPy.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "04-guess-the-number-ai.html#footnotes",
    "href": "04-guess-the-number-ai.html#footnotes",
    "title": "4  Guess the Number: AI takes a turn",
    "section": "",
    "text": "This is the last time, I promise!↩︎\nYou should imagine me as Dora the Explorer staring at you while you think.↩︎\nThe official magic number is 7±2 but reading the original paper tells you that this is more like four for most of us↩︎\nThis is similar to scientific writing, where a single paragraph conveys a single idea. For me, it helps to first write the idea of the paragraph in a single sentence before writing the paragraph itself. If one sentence is not enough, I need to split the text into more paragraphs.↩︎\nThis is not strictly speaking true but that will concern us only once we get to so-called “mutable” objects like lists or dictionaries.↩︎\nIt is normal to have more code devoted to testing than to the actual program.↩︎\nYou still need tests for the integrated system but testing individual functions is a clear prerequisite.↩︎\nThis is also not strictly true but you will have to wait until you learn about named parameters and default values↩︎\nIt is like two persons with identical names, still different people.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guess the Number: AI takes a turn</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html",
    "href": "05-psychopy.html",
    "title": "5  Gettings started with PsychoPy",
    "section": "",
    "text": "5.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#chapter-concepts",
    "href": "05-psychopy.html#chapter-concepts",
    "title": "5  Gettings started with PsychoPy",
    "section": "",
    "text": "Understanding how to use classes and objects.\nUsing named parameters in functions.\nUnderstanding PsychoPy units system.\nUsing basic Psycho visual stimuli and handling user inputs.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#minimal-psychopy",
    "href": "05-psychopy.html#minimal-psychopy",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.2 Minimal PsychoPy code",
    "text": "5.2 Minimal PsychoPy code\nCopy-paste the following code into code01.py file (you did remember to create a new folder for the chapter?):\n\"\"\"\nA minimal PsychoPy code.\n\"\"\"\n\n# this imports two modules from psychopy\n# visual has all the visual stimuli, including the Window class\n# that we need to create a program window\n# event has function for working with mouse and keyboard\nfrom psychopy import visual, event\n\n# creating a 800 x 600 window\nwin = visual.Window(size=(800, 600))\n\n# waiting for any key press\nevent.waitKeys()\n\n# closing the window\nwin.close()\nRun it to check that PsychoPy work. If you get an error saying that psychopy library is not found, check the active Python interpreter. You should get a gray window with PsychoPy title. Press any key (click on the window, if you switched to another one, so that it registers a key press) and it should close. Not very exciting but does show that everything works as it should.\n\nPut the code into code01.py.\n\nThe code is simple but packs quite a few novel bits. First line is easy, we simply import visual and event modules from psychopy library (a library can be itself organized into sublibraries to make things even more modular). Then, we create an object win using a class Window with custom size. Third line uses function waitKeys() from event module to wait for a key press. The last one closes the window by calling its close method. You should have little trouble with lines #1 and #3 but you need to learn about object-oriented programming to understand #2 and #4.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#classes-and-objects",
    "href": "05-psychopy.html#classes-and-objects",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.3 Classes and objects",
    "text": "5.3 Classes and objects\nThe PsychoPy library is a collection of classes that you use to create objects, an approach called object-oriented programming. The core idea is in the name: Instead of keeping variables (data) separate from functions (actions), you combine them in an object that has attributes1 (its own variables) and methods (its own functions). This approach utilizes our natural tendency to perceive the world as a collection of interacting objects.\nFirst, you need to understand an important distinction between classes and objects. A class is a “blueprint” that describes properties and behavior of all objects of that class. This “blueprint” is used to create an instance of that class, which is called an object. For example, Homo sapiens is a class that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class has only a concept of height but no specific height itself. E.g., you cannot ask “What is height of Homo sapiens?” only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say “Run, Homo sapiens! Run!” as abstract concepts have trouble performing real actions like that. Instead, it is Alexander Pastukhov who is an instance of Homo sapiens class with a specific (average) height and a specific (below average) ability to run. Other instances of Homo sapiens (other people) have different height and a different (typically better) ability to run. Thus, a class describes all common properties and methods that all instances of the class (all objects) will have. But an individual object will behave differently because of different values of their properties. This means that whenever you meet a Homo sapien, you could be sure that they have height per se but will need to look at an individual instance to figure what height they have.\nWindow is a class that describes properties that a PsychoPy window must have and actions it can perform (you can see the complete list in the manual). To create an object, we use its class definition and store the result in a variable. In the code above we call Window class2 while passing custom parameters to it (size=(800, 600)) and store an object that it returns in variable win.\nAttributes are, essentially, variables that belong to the class and, therefore, variables that each object will possess. For example, a Window class has size attribute that determines its on-screen size in pixels. It also has (background) color, an attribute that determines whether it should be shown in full screen mode, etc. Thus, a win object will have all these attributes and they will have specific values.\nTo understand both properties and class/object distinction better, put a breakpoint on the third line of code (event.waitKeys()) and fire up the debugger via F5. Once the window is created, the execution will pause and you will find a win object in Variables/Locals. Click on it and it will expand to show all attributes and its values, including size (check that it is [800, 600]). Note that you will not see Window itself in the same list. This is because it is a class, an abstract concept, whereas as win is its instance and object of that class.\nMethods, such as Window.close() are, essentially, functions that belong to the class/object and perform certain actions on the object. For example, method close() closes the window, flip() updates it after we finished drawing in it, etc. What is important is to remember is that each method will act only on the object it belongs to and not on other instances of the same class. This means that you can create two windows (win1 and win2) and calling win1.close() will close the first but not the second window (try this out!). Same goes for attributes, changing them in one object will not affect any other objects of the same class, just like changing a value in one variable will not affect the other ones.\nAlthough we barely scratched the surface of object-oriented programming, it will be enough for us to be able to use classes defined for us in PsychoPy library.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#arguments-by-position-or-name",
    "href": "05-psychopy.html#arguments-by-position-or-name",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.4 Function parameters: default values, passing by position or by name",
    "text": "5.4 Function parameters: default values, passing by position or by name\nThere are a few more curious bits in the visual.Window(size=(800, 600)) call above that we need to discuss. These curiosities are related to functions (and, therefore, methods that are functions that belong to a class) not classes per se. First, constructor method of the Window class has a lot of arguments (when we construct an object, we call a constructor method of the class, which is why we are talking about functions). And yet, we only passed one of them. This is because you can specify default values for individual parameters. In this case, if a parameter is omitted, a default value is used instead\n\ndef divide(x1, x2=2):\n    \"\"\"\n    Divides numbers, uses 2 as a second value if a second term is omitted.\n    \n    Parameters\n    ----------\n    x1 : float\n    x2 : float, default=2\n    \n    Returns\n    ----------\n    number\n    \"\"\"\n    return x1 / x2\n\nprint(divide(2)) # we pass only value for x1 and the default value is used for x2\nprint(divide(2, 4))\n\n1.0\n0.5\n\n\nIf you look at documentation, you will see that for the Window class constructor all parameters have a default value. This is a part of PsychoPy’s philosophy of combining rich customization (just look at the sheer number of parameters!) with simplicity of use through sensible defaults (specify nothing and the window will still work).\nSecond, we did not just pass the value but specified which parameter this value is for via size=(800, 600). This notation is called keyword arguments. The advantage is in making it more explicit which parameter you are passing a value through. Plus, it allows you to put parameters any order, if that is more relevant given the context3. If you do not use names, the values are assigned to individual parameters based on their position (a.k.a. positional parameters). You can even mix the two, but positional parameters must come first, see documentation if you want to know more.\n\n# using positional parameters\nprint(divide(2, 4))\n\n0.5\n\n\n\n# using keyword arguments\nprint(divide(x2=4, x1=2))\n\n0.5\n\n\n\n# mixing positional and keyword arguments\nprint(divide(2, x2=4))\n\n0.5\n\n\n\nprint(divide(2, x1=4))\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 print(divide(2, x1=4))\n\nTypeError: divide() got multiple values for argument 'x1'",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#psychopy-main-loop",
    "href": "05-psychopy.html#psychopy-main-loop",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.5 Adding main loop",
    "text": "5.5 Adding main loop\nCurrently, not much is happening in our program. One thing we need to add is a loop in which we can repeatedly draw in a window (and update it via its flip() method), check user input, and perform any other necessary actions.\nFirst, let us add the loop and handling of user inputs (the fun drawing part will be next). The loop goes between opening and closing the window:\nimporting libraries\nopening the window\n\n--&gt; our main loop &lt;--\n\nclosing the window\nThe loop should be repeated until the user presses an escape key and, therefore, you will need a variable that signals this. My approach is to create a variable gameover initializing it to False and repeat the loop as long as the game not over. Then, in the loop, use function event.getKeys() to check whether escape button was pressed (for this, you need to pass keyList=['escape']). The function returns a list of keys, if any of them were pressed in the meantime or an empty list, if no keys from the keyList were pressed. Store that returned value in a temporary variable (I tend to call it keys). You will learn about lists only in the next chapter, so for now use a ready-made: len(keys) &gt; 0 is a comparison that is True if list is not empty. If the list is indeed not empty, that means that the user pressed escape (as that is the only key that we specified in the function call) and the game should be over. Think how can you do it without an if statement, computing the logical value directly?\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#psychopy-textstim",
    "href": "05-psychopy.html#psychopy-textstim",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.6 Adding text message",
    "text": "5.6 Adding text message\nAlthough we are now running a nice game loop, we still have only a boring gray window to look at. Let us create a text stimulus, which would say “Press escape to exit” and display it during the loop. For this we will use visual.TextStim class from PsychoPy library.\nFirst, you need to create the press_escape_text object (instance of the TextStim) before the main loop. There are quite a few parameters that you can play with but minimally, you need to pass the window the text should be displayed in (our win variable) and the actual text you want to display (text=\"Press escape to exit\"). For all other settings PsychoPy will use its defaults (default font family, color and size, placed right at the windows’ center).\npress_escape_text = visual.TextStim(win, \"Press escape to exit\")\nTo show the visuals in PsychoPy, you first draw each element by calling its draw() method and then update the window by flipping4 it. Note that you call flip() only once after all stimuli are drawn. I typically organize this code into a separate chunk and prepend it with a comment line # drawing stimuli.\nThe # drawing stimuli chunk goes inside the main loop either before or after the keyboard check5. Organize the latter also as a separate code chunk with its own brief comment.\n\nPut your code into code03.py.\n\nNow, you should have a nice, although static, message positioned at the window’s center that tells you how you can exit the game. Check out the manual page for visual.TextStim and try changing it by passing additional parameters to the class call. For example you can change its color, whether text is bold and/or italic, how it is aligned, etc. However, if you want to change where the text is displayed, read on below.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#psychopy-rect",
    "href": "05-psychopy.html#psychopy-rect",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.7 Adding a square and placing it not at the center of the window",
    "text": "5.7 Adding a square and placing it not at the center of the window\nNow, let us figure out how create and move visuals to an arbitrary location on the screen. In principle, this is very straightforward as every visual stimulus (including TextStim we just used) has pos property that specifies (you guessed it!) its position within a window. However, to make your life easier, PsychoPy first complicates it by having five (5!) different position units systems.\nBefore we start exploring the units, let us create a simple white square. The visual class we need is visual.Rect. Just like the TextStim above, it requires win variable (so it knows which window it belongs to), width (defaults to 0.5 of those mysterious units), height (also defaults to 0.5), pos (defaults to (0,0)), lineColor (defaults to white) and fillColor (defaults to None). Thus, to get a “standard” white outline square with size of (0.5, 0.5) units at (0, 0) location you only need pass the win variable: white_square = visual.Rect(win). However, on some computers a curious bug prevents PsychoPy from drawing the outline correctly. If you end up staring at an empty screen6, add fillColor=\"white\" to the call and you should see a filled white square.\nYou draw the square just like you drew the text stimulus, via its draw() method (and, again, you first draw all the stimuli and then flip the window once). Create the code (either keep the text and draw both, or drop the text), run it to see a very white square.\n\nPut your code into code04.py.\n\nWhat? Your square is not really a square? Well, I’ve warned you: Five unit systems!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#psychopy-units",
    "href": "05-psychopy.html#psychopy-units",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.8 Five unit systems",
    "text": "5.8 Five unit systems\n\n5.8.1 Height units\nWith height units everything is specified in the units of window height. The center of the window is at (0,0) and the window goes vertically from -0.5 to 0.5. However, horizontal limits depend on the aspect ratio. For our 800×600 window (4:3 aspect ratio), it will go from -0.666 to 0.666 (the window is 1.3333 window heights wide). For a 600×800 window (3:4 aspect ratio) from -0.375 to 0.375 (the window is 0.75 window heights wide), for a square window 600×600 (aspect ratio 1:1) from -0.5 to 0.5 (again, in all these cases it goes from -0.5 to 0.5 vertically). This means that the actual on-screen distance for the units is the same for both axes. So that a square of size=(0.5, 0.5) is actually a square (it spans the same distance vertically and horizontally). Thus, height units make sizing objects easier but placing them on horizontal axis correctly harder (as you need to know the aspect ratio).\nModify your code by specifying the unit system when you create the window: win = visual.Window(..., units=\"height\"). Play with your code by specifying position of the square when you create it. You just need to pass an extra parameter pos=(&lt;x&gt;, &lt;y&gt;).\n\nPut your code into code05.py.\n\nBy the way, which way is up when y is below or above zero? Unfortunately, unlike x-axis, the y-axis can go both ways. For PsychoPy y-axis points up (so negative values move the square down and positive up). However, if you would use an Eyelink eye tracker to record where participants looked on the screen, it assumes that y-axis starts at the top of the screen and points down7.\nNow, modify the size of the square (and turn it into a non-square rectangle) by passing width=&lt;some-width-value&gt; and height=&lt;some-height-value&gt;.\n\nPut your code into code06.py.\n\n\n\n5.8.2 Normalized units\nNormalized units are default units and assume that the window goes from -1 to 1 both along x- and x-axis. Again, (0,0) is the center of the screen but the bottom-left corner is (-1, -1) whereas the top-right is (1, 1). This makes placing your objects easier but sizing them harder (you need to know the aspect ratio to ensure that a square is a square).\nModify your code, so that it uses \"norm\" units when you create the window and size your white square stimulus, so it does look like a square.\n\nPut your code into code07.py.\n\n\n\n5.8.3 Pixels on screen\nFor pixels on screen units, the window center is still at (0,0) but it goes from -&lt;width-in-pixels&gt;/2 to &lt;width-in-pixels&gt;/2 horizontally (from -400 to 400 in our case) and -&lt;height-in-pixels&gt;/2 to &lt;height-in-pixels&gt;/2 vertically (from -300 to 300). These units could be more intuitive when you are working with a fixed sized window, as the span is the same along the both axes (like for the height units). However, they spell trouble if your window size has changed or you are using a full screen window on a monitor with an unknown resolution. In short, you should use them only if they dramatically simplify your code.\nModify your code to use \"pix\" units and briefly test sizing and placing your square within the window.\n\nPut your code into code08.py.\n\n\n\n5.8.4 Degrees of visual angle\nUnlike the three units above, using degrees of visual angle requires you knowing a physical size of the screen, its resolution, and viewing distance (how far your eyes are away from the screen). They are the measurement units used in visual psychophysics as they describe stimulus size as it appears on the retina (see Wikipedia for details). Thus, these are the units you want to use when running an actual experiment in the lab.\n\n\n5.8.5 Centimeters on screen\nHere, you would need know the physical size of your screen and its resolution. These are fairly exotic units for very specific usage cases8.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#make-your-square-jump",
    "href": "05-psychopy.html#make-your-square-jump",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.9 Make your square jump",
    "text": "5.9 Make your square jump\nSo far, we fixed the location of the square when we created it. However, you can move it at any time by assigning a new (&lt;x&gt;, &lt;y&gt;) coordinates to its pos property. E.g., white_square.pos = (-0.1, 0.2). Let us experiment by moving the square to a random location on every iteration of the loop (this could cause a lot of flashing, so if you have a photosensitive epilepsy that can be triggered by flashing lights, you probably should do it just once before the loop). Use the units of your choice and generate a new position using random.uniform(a, b) function, that generates a random value within a..b range9. Generate two values (one for x, one for y). If you use \"norm\" units, your range is the same (from -1 to 1) for the two dimensions. However, if you used \"height\" units, you need to take into account the aspect ratio of your window (4:3 if you are using 800×600 pix window).\n\nPut your code into code09.py.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#make-the-square-jump-on-your-command",
    "href": "05-psychopy.html#make-the-square-jump-on-your-command",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.10 Make the square jump on your command",
    "text": "5.10 Make the square jump on your command\nThis was very flashy, so let us make the square jump only when you press space button. For this, we need to expand the code that processes keyboard input. So far, we restricted it to just escape button and checked whether any (hence, escape) button was pressed.\nYou will learn about lists and indexes in the next chapter, so here is another ready-made. First, add \"space\" to the keyList parameter. Next, use conditional if statement to check whether event.getKeys() returned a key press. If it did (len(keys) &gt; 0), you can now check whether keys[0] is equal to \"space\" or \"escape\"10. If it was the latter, the game is over as before. If it was \"space\" then move the square to a new random position (and do not move it on every frame!)\nHint, if you are debugging, put you breakpoint inside the if statement, so that the program pauses only once you pressed a key (what happens if you put it on the win.flip() line?)\n\nPut your code into code10.py.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#basics-covered",
    "href": "05-psychopy.html#basics-covered",
    "title": "5  Gettings started with PsychoPy",
    "section": "5.11 Basics covered",
    "text": "5.11 Basics covered\nThere is plenty more to learn about PsychoPy but we’ve got the basics covered. Submit your files and get ready to Whack a Mole!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "05-psychopy.html#footnotes",
    "href": "05-psychopy.html#footnotes",
    "title": "5  Gettings started with PsychoPy",
    "section": "",
    "text": "Also called properties↩︎\nTechnically, we call a class constructor method called __init__ but this is not important for now.↩︎\nHowever, stick to original order for consistency otherwise.↩︎\nThis is called flipping because a window has two buffers: one that is currently displayed on the screen and the other one in which you can draw your stimuli. Once you are done with drawing, you “flip” the buffers so that they exchange their places. Now the one you drew in gets displayed and you have the other buffer to draw in.↩︎\nMy personal preference is to draw first but in most cases it makes no difference.↩︎\nThis sometimes was an issue with Intel graphic cards.↩︎\nThis could be very confusing, if you forget about this when overlaying gaze data on an image you used in the study and wondering what on Earth the participants were doing.↩︎\nSo specific that I cannot think of one, to be honest.↩︎\nYou need to import the random library for this, of course.↩︎\nYou can use if..else, because we only have two options but I would recommend to go for a more general solution if..elif ↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Gettings started with PsychoPy</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html",
    "href": "06-whack-a-mole.html",
    "title": "6  Whack-a-Mole",
    "section": "",
    "text": "6.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#chapter-concepts",
    "href": "06-whack-a-mole.html#chapter-concepts",
    "title": "6  Whack-a-Mole",
    "section": "",
    "text": "Storing many items in lists.\nIterating over items using for loop.\nGenerating a range of numbers using range().\nMaking a pause and limiting time you wait for a key.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#lists",
    "href": "06-whack-a-mole.html#lists",
    "title": "6  Whack-a-Mole",
    "section": "6.2 Lists",
    "text": "6.2 Lists\nSo far, we were using variables to store single values: computer’s pick, player’s guess, number of attempts, PsychoPy window object, etc. But sometimes we need to handle more than one value. We already had this problem in the computer-based Guess-the-Number game when we needed to store the remaining number range. We got away by using two variables, one for the lower and one for the upper limit. However, this approach clearly does not scale well and, sometimes, we might not even know how many values we will need to store. Python’s lists are the solution to the problem.\nA list is a mutable1 sequence of items where individual elements can be accessed via their zero-based index. Extending the idea of variable-as-a-box, you can think about lists as a box with numbered slots. To store and retrieve a particular piece you will need to know both the variable name and the index of the item you are interested in within that box. Then, you work with a variable-plus-index in exactly the same way you work with a normal variable, accessing or changing its value via the same syntax as before.\nA list is defined via square brackets &lt;variable&gt; = [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt;]. An individual slot within a list is also accessed via square brackets &lt;variable&gt;[&lt;index&gt;] where index is, again, zero-based2. This means that the first item is variable[0] and, if there are N items in the list, the last one is variable[N-1]. You can figure out the total number of items in a list by getting its length via a special len() function. Thus, you can access the last item via variable[len(variable)-1]3. Note the -1: If your list has 3 items, the index of the last one is 2, if it has 100, then 99, etc. I am spending so much time on this because it is a fairly common source of confusion.\n\nDo exercise #1 see how lists are defined and indexed.\n\nLists also allow you access more than one slot/index at a time via slicing. You can specify index of elements via &lt;start&gt;:&lt;stop&gt; notation. For example, x[1:3] will give you access to two items with indexes 1 and 2. Yes, two items: Slicing index goes from the start up to but not including the stop. Thus, if you want to get all the items of a list, you will need to write x[0:length(x)] and, yet, to get the last item alone you still write x[len(x)-1]. Confusing? I think so! I understand the logic but I find this stop-is-not-included to be counterintuitive and I still have to consciously remind myself about this. Unfortunately, this is a standard way to define sequences of numbers in Python, so you need to memorize this.\n\nDo exercise #2 to build the intuition.\n\nWhen slicing, you can omit either start or stop. In this case, Python will assume that a missing start means 0 (the index of the first element) and missing stop means len(&lt;list&gt;) (so, last item is included). If you omit both, e.g., my_pretty_numbers[:] it will return all values, as this is equivalent to my_pretty_numbers[0:len(my_pretty_numbers)].4\n\nDo exercise #3.\n\nYou can also use negative indexes that are computed relative to length of the list5. For example, if you want to get the last element of the list, you can say my_pretty_numbers[len(my_pretty_numbers)-1] or just my_pretty_numbers[-1]. The last-but-one element would be my_pretty_numbers[-2], etc. You can use negative indexes for slicing but keep in mind the including-the-start-but-excluding-the-stop catch: my_pretty_numbers[:-1] will return all but last element of the list not the entire list!\n\nDo exercise #4.\n\nSlicing can be extended by specifying a step via start:stop:step notation. step can be negative, allowing you to build indexes in the reverse order:\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers[4:0:-1]\n\n[5, 4, 3, 2]\n\n\nHowever, you must pay attention to the sign of the step. If it goes in the wrong direction then stop cannot be reached, Python will return an empty list.\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers[4:0:1]\n\n[]\n\n\nSteps can be combined with omitted and negative indexes. To get every odd element of the list, you write my_pretty_numbers[::2]:\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers[::2]\n\n[1, 3, 5, 7]\n\n\n\nDo exercise #5.\n\nIf you try to to access indexes outside of a valid range, Python will raise an IndexError6. Thus, trying to get 6th element (index 5) of a five-element-long list will generate a simple and straightforward error. However, if your slice is larger than the range, it will be truncated without an extra warning or an error. So, for a five-element list my_pretty_numbers[:6] or my_pretty_numbers[:600] will both return all numbers (effectively, this is equivalent to my_pretty_numbers[:]). Moreover, if the slice is empty (2:2, cannot include 2 because it is a stop value, even though it starts from 2 as well) or the entire slice is outside of the range, Python will return an empty list, again, neither warning or error is generated.\n\nDo exercise #6.\n\nIn Python lists are dynamic, so you can always add or remove elements to it, see the list of methods. You can add a new item to the of the end of the list via .append(&lt;new_value&gt;) method\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.append(10)\nmy_pretty_numbers\n\n[1, 2, 3, 4, 5, 6, 7, 10]\n\n\nOr, you can insert(&lt;index&gt;, &lt;new_value&gt;) before an element with that index. Unfortunately, this means that you can use an arbitrary large index and it will insert a new value as a last element without generating an error.\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.insert(2, 10)\nmy_pretty_numbers.insert(500, 20)\nmy_pretty_numbers\n\n[1, 2, 10, 3, 4, 5, 6, 7, 20]\n\n\nYou can remove an item using its index via pop(&lt;index&gt;), note that the item is returned as well. If you omit the index, pop() removes the last element of the list. Here, you can only use valid indexes.\n\nmy_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]\nmy_pretty_numbers.pop(-1)\nmy_pretty_numbers.pop(3)\nmy_pretty_numbers\n\n[1, 2, 3, 5, 6]\n\n\n\nDo exercise #7.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#psychopy-scaffolding",
    "href": "06-whack-a-mole.html#psychopy-scaffolding",
    "title": "6  Whack-a-Mole",
    "section": "6.3 Basic game scaffolding",
    "text": "6.3 Basic game scaffolding\nPhew that was a lot about lists7. However, All work and no play makes Jack a dull boy! So let us start with a basic PsychoPy scaffolding. Here the code structure:\nimport libraries (from psychopy)\ncreate the PsychoPy window (visual.Window())\nflip the window (.flip())\nwait for a player to press the escape key (event.waitKeys())\nclose the window (.close())\nTry doing it from scratch. I have left hints to help you with this and you can always consult the online documentation. Do not forget to document the file and to split your code into meaningful chunks with comments (if needed).\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#three-moles",
    "href": "06-whack-a-mole.html#three-moles",
    "title": "6  Whack-a-Mole",
    "section": "6.4 Three moles",
    "text": "6.4 Three moles\nLet us create three moles that will be represented by circles. Create a new list variable moles and put three circles into it. One should go to the left, one dead center, and one to the right. Watch a video above to see what I mean. Think of a reasonable size (which units make keeping circle a circle easier?) and position. You can also use different colors for them, as I did.\nYou can either create an empty list and then .append() circles one at a time or you can use square brackets to put all three of them into the list in one go. Then draw() circles before you flip the window and wait for a key press. Note that you have to draw them one at a time. Therefore, you will need to add three lines for this but the next section will show you an easier way.\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#for-loop",
    "href": "06-whack-a-mole.html#for-loop",
    "title": "6  Whack-a-Mole",
    "section": "6.5 For loop",
    "text": "6.5 For loop\nIn the code above, we needed to iterate over three moles (circles) that we had in a list. Python has a tool just for that: a for loop that iterates over the items in any sequence (our list is a sequence!). Here is an example:\n\nnumbers = [2, 4, 42]\nfor a_number in numbers:\n    print(\"Value of a_number variable on this iteration is %d\"%(a_number))\n    a_number = a_number + 3\n    print(\"  Now we incremented it by 3: %d\"%(a_number))\n    print(\"  Now we use in a formula a_number / 10: %g\"%(a_number / 10))\n\nValue of a_number variable on this iteration is 2\n  Now we incremented it by 3: 5\n  Now we use in a formula a_number / 10: 0.5\nValue of a_number variable on this iteration is 4\n  Now we incremented it by 3: 7\n  Now we use in a formula a_number / 10: 0.7\nValue of a_number variable on this iteration is 42\n  Now we incremented it by 3: 45\n  Now we use in a formula a_number / 10: 4.5\n\n\nHere, the code inside the for loop is repeated three times because there are three items in the list. On each iteration, next value from the list gets assigned to a temporary variable a_number (see the output). Once the value is assigned to a variable, you can use it just like any variable. You can print it out (first print), you can modify it (second line within the loop), use its value for when calling other functions, etc. To better appreciate this, copy-paste this code into a temporary file (call it test01.py), put a breakpoint onto the first print statement and then use F10 to step through the loop and see how value of a_number variable changes on each iteration and then it gets modified in the second line within the loop.\nNote that you can use the same break statement as for the while loop.\n\nDo exercise #8.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#drawing-in-a-loop",
    "href": "06-whack-a-mole.html#drawing-in-a-loop",
    "title": "6  Whack-a-Mole",
    "section": "6.6 Drawing in a loop",
    "text": "6.6 Drawing in a loop\nNow that you have learned about the for loop, it is easy to draw the moles. Just iterate over the list (come up with a good temporary variable name) and draw() a current item (which is in your temporary variable).\n\nPut your code into code03.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#range",
    "href": "06-whack-a-mole.html#range",
    "title": "6  Whack-a-Mole",
    "section": "6.7 range() function: Repeating code N times",
    "text": "6.7 range() function: Repeating code N times\nSometimes, you might need to repeat the code several times. For example, imagine that you have 40 trials in an experiment. Thus, you need to repeat a trial-related code 40 times. You can, of course, build a list 40 items long by hand and iterate over it but Python has a handy range() function for that. range(N) yields N integers from 0 to N-1 (same up-to-but-not-including rule as for slicing) that you can iterate over in a for loop.\n\nfor x in range(3):\n    print(\"Value of x is %d\"%(x))\n\nValue of x is 0\nValue of x is 1\nValue of x is 2\n\n\nYou can modify range() function behavior by providing a starting value and a step size. But in its simplest form range(N) is a handy tool to repeat the code that many times. Note that while you always need to have a temporary variable in a for loop, sometimes you may not use it at all. In cases like this, you should use _ (underscore symbol) as a variable name to indicate the lack of use.\n\nfor _ in range(2):\n    print(\"I will be repeated twice!\")\n\nI will be repeated twice!\nI will be repeated twice!\n\n\nAlternatively, you can use range() to loop through indexes of a list (remember, you can always access an individual list item via var[index]). Do exactly that8! Modify your code to use range() function in the for loop (how can you compute the number of iterations you need from the length of the list?), use temporary variable as an index for the list to draw each item9. When in doubt, put a breakpoint inside (or just before) the loop and step through your code to understand what values a temporary loop variable gets and how it is used.\n\nPut your modified code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#random-mole",
    "href": "06-whack-a-mole.html#random-mole",
    "title": "6  Whack-a-Mole",
    "section": "6.8 A random mole",
    "text": "6.8 A random mole\nDrawing all three moles served as a practical exercise with loops but in a real game we need to shown only one random target at a time. We could create the three targets as before and draw one of them. However, later on we would like to change the color of the target to indicate that the player did hit it, so it is simpler (if a bit wasteful) to create a single mole every time we need one.\nFor this, define one CONSTANT with a list of three colors that you used and another one with three horizontal locations (the vertical location is the same, so we do not need to worry about it). Next, randomly pick which target out of three you want to create, i.e., we need to generate an index of the target and use that index to figure out target’s location and color. You can do it either via random.randrange() or via random.choice() building the range yourself via the function with the same name you have just learned about (remember to organize your imports alphabetically). Store the index in a variable with a meaningful name10 and use it with constants to create the target of the corresponding color at a corresponding location. Then, you need to draw that single target before waiting for a key press.\nOnce you have the code, put a breakpoint and check that the value of the index variable matches what is shown on a screen11.\n\nPut your modified code into code05.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#clock-wait",
    "href": "06-whack-a-mole.html#clock-wait",
    "title": "6  Whack-a-Mole",
    "section": "6.9 Random time",
    "text": "6.9 Random time\nWhat makes Whack-a-Mole game fun is not only that you do not know which mole will appear but you also do not know when it will appear and how much time you have to whack it. Thus, we need to modify our presentation schedule. We need a blank period of a random duration (I would suggest between 0.75 s to 1.5 s) and limited presentation duration (between 0.5 to 0.75 s). First, you need to define these ranges as constants. Now that you know lists you can use a single variable to hold both ends of the range. Then, you need to generate two numbers (one for the blank another for the presentation) coming from a uniform distrubition within that range.\nHere, a CONSTANT will hold values for two parameters of random.uniform() function and there are two ways of using them. First, you can use an index 0 to get the value for the first parameter and 1 for the second parameter:\nimport random\n\nTIME_UNTIL_BEEP = [0.1, 0.3]\nrandom.uniform(TIME_UNTIL_BEEP[0], TIME_UNTIL_BEEP[1])\nHowever, Python has a nifty trick called Unpacking Argument Lists: You can pass a list of arguments prepended by an asterisk and Python will unpack the list into arguments in the same order they are in the list: first value goes to the parameter, second value to the second parameter, etc. So, in our case, the code can be simplified to\nrandom.uniform(*TIME_UNTIL_BEEP)\nNote that it is on you to make sure that the number and the order of elements in the list match function parameters!\n\ndef single_parameter_function(x):\n  \"\"\"Do nothing but require a single paramter\n  \"\"\"\n  pass\n\nTWO_VALUES = [1, 3]\n\nsingle_parameter_function(*TWO_VALUES)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 8\n      4   pass\n      6 TWO_VALUES = [1, 3]\n----&gt; 8 single_parameter_function(*TWO_VALUES)\n\nTypeError: single_parameter_function() takes 1 positional argument but 2 were given\n\n\n\nBack to the game, use random.uniform() function to generate random blank and presentation times, store them into variables of your choice, and time your blank and presentation using the wait() function from the clock module.\nNow is time to update and structure you code. Here is a approximate outline (note that I have dropped the wait for keys):\n\"\"\"Document your file\n\"\"\"\nimport all libaries you need in an alphabetical order\n\ndefine CONSTANTS\n\ncreate window\n\n# generating random parameters for the trial\npick random index for the mole\ncreate the mole\ngenerate random durations for blank and presentation interval\n\n# blank\nclear window (win.flip() alone)\nwait for \"blank duration\" seconds\n\n# presentation\ndraw the mole\nwait for \"presentation duration\" seconds\n\nclose the window\nNote that it has no response processing at the moment and that window should close right after the stimulus is presented.\n\nPut your code into code06.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#repeating-trials",
    "href": "06-whack-a-mole.html#repeating-trials",
    "title": "6  Whack-a-Mole",
    "section": "6.10 Repeating trials",
    "text": "6.10 Repeating trials\nYou already know how to repeat the same code many times. Decide on number of trials / rounds (define this as a CONSTANT) and repeat the single round that many times. Think about what code goes inside the loop and what should stay outside for the randomization to work properly.\n\nPut your code into code07.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#waitKeys-maxwait",
    "href": "06-whack-a-mole.html#waitKeys-maxwait",
    "title": "6  Whack-a-Mole",
    "section": "6.11 Exit strategy",
    "text": "6.11 Exit strategy\nI hope that you used a small number of trials because (on my advice, yes!) we did not program a possibility to exit the game via the escape key. To put it in, we will replace both wait() calls with waitKeys() function. It has maxWait parameter that by default is set to infinity but can be set to the duration we require. If a player does not press a key, it will work just like wait() did. If a player presses a key (allow only \"escape\" for now), it means that they want to abort the game (the only possible action at the moment). Thus, assign the returned value to a temporary variable (keys?) and check whether it is equal to None12. If it is not equal to None, break out of the loop!\n\nPut your code into code08.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#whack-mole",
    "href": "06-whack-a-mole.html#whack-mole",
    "title": "6  Whack-a-Mole",
    "section": "6.12 Whacking that mole",
    "text": "6.12 Whacking that mole\nWe have moles that appear at a random location after a random delay for a random period of time. Now we just need to add an ability to whack ’em! You whack a mole only when it is present. Thus, we only need to modify and handle the waitKeys() call for the presentation interval.\nFirst, create a new constant with three keys that correspond to three locations. I would suggest using [\"left\", \"down\", \"right\"], which are cursor keys13. Next, you need to use them for the keyList parameter. However, we cannot use this list directly, as we also need the escape key. The simplest way is to put “escape” into its own list and concatenate the two lists via +: [\"escape\"] + YOUR_CONSTANT_WITH_KEYS. Do this concatenation directly when you set a value to the keyList in the function call. Before we continue, run the code and test that you can abort the program during the presentation (but not during the blank interval) by pressing any of these three keys. Also check that escape still works!\nNow that we have keys to press, we need more sophisticated processing (we gonna have quite a few nested conditional statements). We still need to check whether waitKeys() returned None first. If it did not, it must have returned a list of pressed keys. Actually, it will be a list with just a single item14, so we can work with it directly via keys[0]. Use conditional if-else statement to break out of the loop if the player pressed escape. Otherwise, it was one of the three “whack” keys.\nOur next step is to establish which index the key corresponds to. Python makes it extremely easy as lists have .index(value) method that returns the index of the value within the list. You have the (CONSTANT) list with the keys and you have the pressed key: Figure out the index and check whether it matches the index of the target (imole variable in my code). If it does, let us provide a visual feedback of success: change mole (circle) fillColor to white, draw it, and wait for 300 ms (setup a constant for feedback duration). This way, the mole will turn white and remain briefly on the screen when hit but will disappear immediately, if you missed.\n\nPut your code into code09.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#you-did-it",
    "href": "06-whack-a-mole.html#you-did-it",
    "title": "6  Whack-a-Mole",
    "section": "6.13 You did it!",
    "text": "6.13 You did it!\nCongratulations on your first video game! It could use some bells-and-whistles like having a score, combos would be cool, proper mole images instead of a circle, etc. but it works and it is fun (if you do not feel challenged, reduce the presentation time)! Submit your files and next time we will ditch the keyboard and learn how to handle the mouse in the Memory game.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "06-whack-a-mole.html#footnotes",
    "href": "06-whack-a-mole.html#footnotes",
    "title": "6  Whack-a-Mole",
    "section": "",
    "text": "More on that and tuples, list’s immutable cousins, later.↩︎\nThis is typical for “classic” programming languages but less so for ones that are linear algebra / data science oriented. Both Matlab and R use one-based indexing, so you need to be careful and double-check whether you are using correct indexes.↩︎\nThere is a simpler way to do this, which you will learn in a little while.↩︎\nNote, that this is almost but not quite the same thing as just writing my_pretty_numbers, as my_pretty_numbers[:] returns a different list with identical content. The difference is subtle but important and we will return to it later when talking about mutable versus immutable types.↩︎\nIf you are coming from R, negative indexing is completely different in Python.↩︎\nIf you are familiar with R and its liberal attitude towards indexes, you will find this very satisfying.↩︎\nAnd we barely scratched the surface!↩︎\nNote, this is not a better way but an alternative way to do this.↩︎\nStyle hint: if a variable is an index of something, I tend to call it isomething. E.g., if it holds an index to a current mole, I would call it imole. This is my way of doing it. Others use i_ prefix or an _i suffix. But either way, it is a useful naming convention. Remember, the easier it is to understand the meaning of a variable from its name, the easier it is for you to read and modify the code.↩︎\nitarget? imole?↩︎\nI know it feels redundant but these are little checks that cost little time by themselves but help you avoid wasting lots of time on tracing weird mistakes. Here, you check that your expectations (if the middle target is shown, the index should be 1) match the reality. Once you check this, you do not expect it to be true, you know it to be true!↩︎\nConfusingly, if no key was pressed, getKeys() returns an empty list that has length of zero but waitKeys() returns None and None has no length.↩︎\nWant to know key codes for sure? Write a small program that opens a window and then repeatedly waits for any key press and prints out into console.↩︎\nYou will get more than one item in that list only if you set clearEvents=False. In this case, you will get the list of keys pressed before the call. However, if you opted for a default clearEvents=True, you will get only one key press in the list (at least I was never able to get more than one).↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Whack-a-Mole</span>"
    ]
  },
  {
    "objectID": "07-memory.html",
    "href": "07-memory.html",
    "title": "7  Memory game",
    "section": "",
    "text": "7.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#chapter-concepts",
    "href": "07-memory.html#chapter-concepts",
    "title": "7  Memory game",
    "section": "",
    "text": "Mutable vs. immutable objects\nShowing images.\nWorking with files via os library.\nUsing dictionaries.\nPerforming list operations.\nLooping over both index and item via list enumeration.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#variables-as-boxes-immutable-objects",
    "href": "07-memory.html#variables-as-boxes-immutable-objects",
    "title": "7  Memory game",
    "section": "7.2 Variables as boxes (immutable objects)",
    "text": "7.2 Variables as boxes (immutable objects)\nIn this game, you will use dictionaries. These are mutable, like lists in contrast to “normal” immutable values (integers, floats, strings). You need to learn about this distinction as these two kinds of objects (values) behave very differently under some circumstances, which is both good (power!) and bad (weird unexpected behavior!) news.\nYou may remember the variable-as-a-box metaphor that I used to introduce variables. In short, a variable can be thought of as a “box” with a variable name written on it and a value being stored “inside”. When you use this value or assign it to a different variable, you can assume that Python makes a copy of it2 and puts that copy into a different variable “box”. When you replace value of a variable, you take out the old value, destroy it (by throwing it into a nearest black hole, I assume), create a new one, and put it into the variable “box”. When you change a variable based on its current state, the same thing happens. You take out the value, create a new value (by adding to the original one or doing some other operation), destroy the old one, and put the new one back into the variable “box”. The important point is that although a variable can have different immutable values (we changed imole variable on every round), the immutable value itself never changes. It gets replaced with another immutable value but never changes3.\nThe box metaphor explains why scopes work the way they do. Each scope has its own set of boxes and whenever you pass information between scopes, e.g., from a global script to a function, a copy of a value (from a variable) is created and put into a new box (e.g., a parameter) inside the function. When a function returns a value, it is copied and put in one of the boxes in the global script (variable you assigned the returned value to), etc.\nHowever, this is true only for immutable objects (values) such as numbers, strings, logical values, etc. but also tuples (see below for what these are). As you could have guessed from the name, this means that there are other mutable objects and they behave very differently.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#mutable-objects",
    "href": "07-memory.html#mutable-objects",
    "title": "7  Memory game",
    "section": "7.3 Variables as post-it stickers (mutable objects)",
    "text": "7.3 Variables as post-it stickers (mutable objects)\nMutable objects are, for example, lists or dictionaries4, i.e., things that can change. The key difference is that immutable objects can be thought as fixed in their size. A number takes up that many bytes to store, same goes for a given string (although a different string would require more or fewer bytes). Still, they do not change, they are created and destroyed when unneeded but never truly updated.\nMutable objects can be changed5. For example, you can add elements to your list, or remove them, or shuffle them. Same goes for dictionaries. Making such object immutable would be computationally inefficient: Every time you add a value a (long) list is destroyed and recreated with just that one additional value. Which is why Python simply updates the original object. For further computation efficiency, these objects are not copied when you assign them to a different variable or use as a parameter value but are passed by reference. This means that the variable is no longer a “box” you put values into but a “sticker” you put on an object (a list, a dictionary). And you can put as many stickers on an object as you want and it still will be the same object!\nWhat on Earth do I mean? Keeping in mind that a variable is just a sticker (one of many) on a mutable object, try figuring out what will be the output below:\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)\n\nDo exercise #1.\n\nHuh? That is precisely what I meant with “stickers on the same object”. First, we create a list and put an x sticker on it. Then, we assign the same list to y, in other words, we put a y sticker on the same list. Since both x and y are stickers on the same object, they are, effectively, synonyms. In that specific situation, once you set x = y, it does not matter which variable name you use to change the object, they are just two stickers hanging side-by-side on the same list. Again, just a reminder, this is not what would happen for immutable values, like numbers, where things would behave the way you expect them to behave.\nThis variable-as-a-sticker, a.k.a. “passing value by reference”, has very important implications for function calls, as it breaks your scope without ever giving you a warning. Look at the code below and try figuring out what the output will be.\ndef change_it(y):\n    y.append(4)\n\nx = [1, 2, 3]\nchange_it(x)\nprint(x)\n\nDo exercise #2.\n\nHow did we manage to modify a global variable from inside the function? Didn’t we change the local parameter of the function? Yep, that is exactly the problem with passing by reference. Your function parameter is yet another sticker on the same object, so even though it looks like you do not need to worry about global variables (that’s why you wrote the function and learned about scopes!), you still do. If you are perplexed by this, you are in a good company. This is one of the most unexpected and confusing bits in Python that routinely catches people6 by surprise. Let us do a few more exercises, before I show you how to solve the scope problem for mutable objects.\n\nDo exercise #3.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#tuple",
    "href": "07-memory.html#tuple",
    "title": "7  Memory game",
    "section": "7.4 Tuple: a frozen list",
    "text": "7.4 Tuple: a frozen list\nThe wise people who created Python were acutely aware of the problem that the variable-as-a-sticker creates. Which is why, they added an immutable version of a list, called a tuple. It is a “frozen” list of values, which you can loop over, access its items by index, or figure out how many items it has, but you cannot modify it. No appending, removing, replacing values, etc. For you this means that a variable with a frozen list is a box rather than a sticker and that it behaves just like any other “normal” immutable object. You can create a tuple by using round brackets.\ni_am_a_tuple = (1, 2, 3)\nYou can loop over it, e.g.,\n\ni_am_a_tuple = (1, 2, 3)\nfor number in i_am_a_tuple:\n    print(number)\n\n1\n2\n3\n\n\nbut, as I said, appending will throw a mistake\n\ni_am_a_tuple = (1, 2, 3)\n\n# throws AttributeError: 'tuple' object has no attribute 'append'\ni_am_a_tuple.append(4)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[2], line 4\n      1 i_am_a_tuple = (1, 2, 3)\n      3 # throws AttributeError: 'tuple' object has no attribute 'append'\n----&gt; 4 i_am_a_tuple.append(4)\n\nAttributeError: 'tuple' object has no attribute 'append'\n\n\n\nSame goes for trying to change it\n\ni_am_a_tuple = (1, 2, 3)\n\n# throws TypeError: 'tuple' object does not support item assignment\ni_am_a_tuple[1] = 1 \n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 4\n      1 i_am_a_tuple = (1, 2, 3)\n      3 # throws TypeError: 'tuple' object does not support item assignment\n----&gt; 4 i_am_a_tuple[1] = 1 \n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nThis means that when you need to pass a list of values to a function and you want them to have no link to the original variable, you should instead pass a tuple of values to the function. The function still has a list of values but the link to the original list object is now broken. You can turn a list into a tuple using tuple(). Keeping in mind that tuple() creates a frozen copy of the list, what will happen below?\nx = [1, 2, 3]\ny = tuple(x)\nx.append(4)\nprint(y)\n\nDo exercise #4.\n\nAs you probably figured out, when y = tuple(x), Python creates a copy of the list values, freezes them (they are immutable now), and puts them into the “y” box. Hence, whatever you do to the original list, has no effect on the immutable “y”.\nConversely, you “unfreeze” a tuple by turning it into a list via list(). Please note that it creates a new list, which has no relation to any other existing list, even if values are the same or were originally taken from any of them!\n\nDo exercise #5.\n\nRemember I just said that list() creates a new list? This means that you can use it to create a copy of a list directly, without an intermediate tuple step. This way you can two different lists with identical values. You can also achieve the same results by slicing an entire list, e.g. list(x), is the same as x[:].\n\nDo exercise #6.\n\nHere, y = list(x) created a new list (which was a carbon copy of the one with the “x” sticker on it) and the “y” sticker was put on that new list, while the “x” remained hanging on the original.\nIf you feel your head spinning then, unfortunately, I have to tell that it gets even worse. The following paragraph covers fairly advanced scenario but I want you to know about it, as things work extremely counterintuitively and I personally have been caught by this issue a few times and it always took me forever to figure out the problem. Thus, I want you to be at least aware of it. What if you have a tuple (immutable!) that contains a list (mutable) inside? As I told you before, you cannot modify the item itself but that item is merely a reference to list (a sticker on a mutable object!), so even though tuple is immutable, you can still fiddle with the list itself. Moreover, making a copy of a tuple will merely make a copy of a reference that still points to the same list! So, you could be thinking that since it is all tuples everything is immutatable and well-behaving and be caught out by that7. Here is an example of such a mess:\n\ntuple_1 = tuple([1, [\"A\", \"B\"], 2])\ntuple_2 = tuple_1\n\n# This (correctly) does not work\ntuple_1[0] = [\"C\", \"D\"]\n\n# But we can change first element of the list to \"C\" and second to \"D\"\n# Reference to the list is frozen, but the list itself is mutable!\ntuple_1[1][0] = \"C\"\ntuple_2[1][1] = \"D\"\n\nprint(tuple_1)\nprint(tuple_2)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[4], line 5\n      2 tuple_2 = tuple_1\n      4 # This (correctly) does not work\n----&gt; 5 tuple_1[0] = [\"C\", \"D\"]\n      7 # But we can change first element of the list to \"C\" and second to \"D\"\n      8 # Reference to the list is frozen, but the list itself is mutable!\n      9 tuple_1[1][0] = \"C\"\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\nConfusing? You bet! If you feel overwhelmed by this whole immutable/mutable, tuple/list, copy/reference confusion, you are just being a normal human being. I understand the (computational) reasons for doing things this way, I am aware of this difference and how useful this can be but it still catches me by surprise from time to time! So, the word of advice, be careful and double-check your code using debugger whenever you are assigning list or dictionaries, passing them to functions, making copies, having lists inside lists, etc. Be aware that things may not work as you think they should!",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#minimal-code",
    "href": "07-memory.html#minimal-code",
    "title": "7  Memory game",
    "section": "7.5 Minimal code",
    "text": "7.5 Minimal code\nEnough of theory, let us get busy writing the game. As usual, let us start with a minimal code (try doing it from scratch instead of copy-pasting from the last game):\nimporting psychopy modules that we need\n \ncreating a window of a useful size and useful units\n\nwaiting for a key press\n\nclosing the window\nThe first thing you need to decide on is the window size in pixels and which units would sizing and placing cards easier. Each chicken image is 240×400 pixels and, for the game, we need place for exactly 4×2 images, i.e. our window must be 4 cards wide and 2 cards high. Do not forget to document the file!\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#imagestim",
    "href": "07-memory.html#imagestim",
    "title": "7  Memory game",
    "section": "7.6 Drawing an image",
    "text": "7.6 Drawing an image\nWe used (abstract and boring) circles to represent moles but today we will use actual images of chicken (see instructions above on downloading them). Using an image stimulus in PsychoPy is very straightforward because it behaves very much like other visual stimuli you already know. First, you need to create an new object by calling visual.ImageStim(...). You can find the complete list of parameters in the documentation but for our initial intents and purposes, we only need to pass three of them:\n\nour window variable: win.\nimage file name: image=\"Images/r01.png\" (images are in a subfolder and therefore we need to use a relative path).\nsize: size=(???, ???). That is one for you to compute. If you picked norm units, as I did, then window is 2 units wide and 2 units high but for height it is 1 units height and aspect-ratio units wide. We want to have a 4×2 images, what is the size (both width and height) of each image in the units of your choice?\n\nDraw the chicken image (it should appear at the center of the screen).\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#placing-an-image-index-to-position",
    "href": "07-memory.html#placing-an-image-index-to-position",
    "title": "7  Memory game",
    "section": "7.7 Placing an image (index to position)",
    "text": "7.7 Placing an image (index to position)\nBy default, our image is placed at the center of the screen, which is a surprisingly useful default for a typical psychophysical experiment that shows stimuli at fixation (which is also, typically, at the center of the screen). However, we will need to draw eight images, each at its designated location. You need to create a function that takes an image index (it goes 0 to 7) and returns a list with a pair of values with its location on the screen. Below is a sketch of how index correspond to the location. Note that image location (pos corresponds to the center of the image.\n\n\n\nCard location index\n\n\nName the function position_from_index. It should take one argument (index) and return a list with [&lt;x&gt;, &lt;y&gt;] coordinates in the PsychoPy units (from now on I assume that these are norm). You can then use this value for the pos argument of the ImageStim().\nThe computation might look complicated, so let me get you started. How can you compute x coordinate for the top row? Concentrating on the top row alone makes things simpler because here the column index is the same as the overall index: The left-most column is 0, the next one is 1, etc. You need a simple algebra of \\(x = a_x + b_x \\cdot column\\). You can easily deduce out both \\(a_x\\) and \\(b_x\\) if you figure out locations of the first and second cards by hand. Same goes for the y coordinate. Assuming that you know the row, which is either 0 (top row) or 1 (bottom row), you can compute \\(y = a_y + b_y \\cdot row\\) (note that rows go top-to-bottom but PsychoPy coordinates go bottom-to-top).\nBut, I hear you say, you do not have row and column indexes, only the overall index? To compute those you only need to keep in mind that each row has four cards. Then, you can make use of two special division operators: floor division operator // and modulos, divison remainder % operators. The former returns only the integer part of the division, so that 4 // 3 is 1 (because 4/3 is 1.33333) and 1 // 4 is 0 (because 1/4 is 0.25). The latter returns the remaining integers, so that 4 % 3 is 1 and 1 % 4 is 0. These two operators are enough for you to compute row and column indexes.\nMy suggestion would be first to play with individual formulas in Jupyter Notebook, which makes it easier to try out (dividing) things and seeing the result, putting various values into formulas, etc. Once you are confident that the code is working, turn it into a function, document it, and put into a separate file (utilities.py, do not forget to put a comment at the top of the file as well!). You can then import it in the main script and use it to place the card. Try out different indexes and make sure that the card appears where it should. Remember, put a breakpoint and step through the program while watching variables, if things do not work as you expected.\n\nPut position_from_index into utilities.py. Put updated code into code03.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#backside-of-the-card",
    "href": "07-memory.html#backside-of-the-card",
    "title": "7  Memory game",
    "section": "7.8 Backside of the card",
    "text": "7.8 Backside of the card\nA chicken image is a card’s face but the game starts with the cards face down, so the player should see their backs. We will use a plain rectangle as a backside. Pick a nice looking combination of fillColor (inside) and lineColor (contour) colors, the only requirement is that they are different, as otherwise it will be impossible to see individual cards. Modify your code, to draw image (face of the card) and rectangle (back of the card) side-by-side (e.g., if face is at position with index 0, rectangle should be at position 1 or 4). This way you can check that sizes match and that they are positioned correctly.\n\nPut your code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#dictionaries",
    "href": "07-memory.html#dictionaries",
    "title": "7  Memory game",
    "section": "7.9 Dictionaries",
    "text": "7.9 Dictionaries\nEach card that we use has plenty of properties: A front (image), a back (rectangle), and will have other properties such as which side should be shown or whether card is already taken off the screen. This calls for a container, so we could put all these relevant bits into a single variable. We could put these values into a list and use numerical indexes to access individual elements (e.g., card[0] would be front image but card[2] would indicate the active side) but indexes do not have meaning per se, so figuring out how card[0] is different from card[2] would be tricky. Python has a solution for cases like this: dictionaries.\nA dictionary is a container that stores information using key : value pairs. This is similar to how you look up a meaning or a translation (value) of a word (key) in a real dictionary, hence the name. To create a dictionary, you use curly brackets {&lt;key1&gt; : &lt;value1&gt;}, {&lt;key2&gt; : &lt;value2&gt;, ...} or create it via dict(&lt;key1&gt;=&lt;value1&gt;, &lt;key2&gt;=&lt;value2&gt;, ...). Note that the second version is more restrictive as keys must follow rules for variable names, whereas in curly-brackets version keys can be arbitrary strings.\nbook = {\"Author\" : \"Walter Moers\",\n        \"Title\": \"Die 13½ Leben des Käpt'n Blaubär\"}\n        \n# or, equivalently\nbook = dict(Author=\"Walter Moers\",\n            Title=\"Die 13½ Leben des Käpt'n Blaubär\")\nOnce you created a dictionary, you can access or modify each field using its key, e.g. print(book[\"Author\"]) or book[\"Author\"] = \"Moers, W.\". You can also add new fields by assigning values to them, e.g., book[\"Publication year\"] = 1999. In short, you can use a combination of &lt;dictionary-variable&gt;[&lt;key&gt;] just like you would use a normal variable. This is similar to using the list[index] combination, the only difference is that index must be an integer, whereas key can be any hashable8 value.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#using-a-dictionary-to-represent-a-card",
    "href": "07-memory.html#using-a-dictionary-to-represent-a-card",
    "title": "7  Memory game",
    "section": "7.10 Using a dictionary to represent a card",
    "text": "7.10 Using a dictionary to represent a card\nOur card has the following properties, so these will be key-value entries in a dictionary\n\n\"front\": front side (image of a chicken).\n\"back\": back side (rectangle).\n\"filename\": identity on the card that we will use later to check whether the player opened two identical cards (their filenames match) or two different ones.\n\"side\": can be either \"front\" or \"back\", information about which side is up (drawn on the screen). Set it to \"back\" because, initially, all cards are face down. However, you can always set it temporarily to \"front\" to see how the cards are distributed.\n\"show\": a logical value, set it to True. We will use it later to mark out cards that are off the table and are, therefore, not shown. Initially, all cards are shown, so all cards should be created with \"show\" being equal to True.\n\nCreate a dictionary variable (name it card) and fill it with relevant values (use either \"front\" and “back\" for \"side\" key) and stimuli (you can put PsychoPy stimuli into a dictionary just like we put them into a list earlier). Modify your code so that it draws the correct image based on the value of the \"side\" entry. Note that you do not need an if-statement for this! Think about a key you need to access these two sides and the value that you have in for the \"side\" key.\n\nPut your code into code05.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#card-factory",
    "href": "07-memory.html#card-factory",
    "title": "7  Memory game",
    "section": "7.11 Card factory",
    "text": "7.11 Card factory\nYou have the code to create one card but we need eight of them. This definitely calls for a function. Write a function (put it into utilities.py to declutter the main file) that takes three parameters\n\na window variable (you need it to create PsychoPy stimuli),\na filename,\ncard position index,\n\nand returns a dictionary, just like the one you created. You very much have the code, you only need to wrap it into a function and document it. Call function create_card_path9 and use it in the main script to create card dictionary. Think about libraries you will now need to import in utilities.py.\n\nPut create_card_path into utilities.py. Put code into code06.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#file-list",
    "href": "07-memory.html#file-list",
    "title": "7  Memory game",
    "section": "7.12 Getting a list of files",
    "text": "7.12 Getting a list of files\nFor a single card, we simply hard-coded the name of an image file, as well as its location. However, for a real game (or an experiment) we would like to be more flexible and automatically determine which files we have in the Images folder. This is covered by os library that contains various utilities for working with your operating system and, in particular, with files and directories. Specifically, os.listdir(path=“.”) returns a list with filenames of all the files in a folder specified by path. By default, it is a current path (path=\".\"). However, you can use either a relative path - os.listdir(\"Images\"), assuming that Images is a subfolder in your current directory - or an absolute path os.listdir(\"E:/Teaching/Python/MemoryGame/Images\") (in my case)10.\nTry this out in a Jupyter Notebook (do not forget to import the os library). You should get a list of 8 files that are coded as [r|l][index].png, where r or l denote a direction the chicken is looking. However, for our game we need only four images (4 × 2 = 8 cards). Therefore, we need to select a subset of them, e.g., four chicken looking to the left or to the right only. Here, let us work with chicken looking to the left, meaning that we need to pick only files that start with “l”. To make this filtering easier, we will use a cool Python trick called list comprehensions.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#list-comprehension",
    "href": "07-memory.html#list-comprehension",
    "title": "7  Memory game",
    "section": "7.13 List comprehension",
    "text": "7.13 List comprehension\nList comprehension provides an elegant and easy-to-read way to create, modify and/or filter elements of the list creating a new list. The general structure is\nnew_list = [&lt;transformation-of-the-item&gt; for item in old_list if &lt;condition-given-the-item&gt;]\nLet us look at examples to understand how it works. Imagine that you have a list numbers = [1, 2, 3] and you need increment each number by 111. You can do it by creating a new list and adding 1 to each item in the  part:\nnumbers = [1, 2, 3]\nnumbers_plus_1 = [item + 1 for item in numbers]\nNote that this is equivalent to\nnumbers = [1, 2, 3]\nnumbers_plus_1 = []\nfor item in numbers:\n    numbers_plus_1.append(item + 1)\nOr, imagine that you need to convert each item to a string. You can do it simply as\nnumbers = [1, 2, 3]\nnumbers_as_strings = [str(item) for item in numbers]\nWhat would be an equivalent form using a normal for loop? Write both versions of code in Jupiter cells and check that the results are the same.\n\nDo exercise #7 in Jupyter notebook.\n\nNow, implement the code below using list comprehension. Check that results match.\nstrings = ['1', '2', '3']\nnumbers = []\nfor astring in strings:\n    numbers.append(int(astring) + 10)\n\nDo exercise #8 in Jupyter notebook.\n\nAs noted above, you can also use a conditional statement to filter which items are passed to the new list. In our numbers example, we can retain numbers that are greater than 1\nnumbers = [1, 2, 3]\nnumbers_greater_than_1 = [item for item in numbers if item &gt; 1]\nSometimes, the same statement is written in three lines, instead of one, to make reading easier:\nnumbers = [1, 2, 3]\nnumbers_greater_than_1 = [item \n                          for item in numbers\n                          if item &gt; 1]\nYou can of course combine the transformation and filtering in a single statement. Create code that filters out all items below 2 and adds 4 to them.\n\nDo exercise #9 in Jupyter notebook.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#get-relevant-files",
    "href": "07-memory.html#get-relevant-files",
    "title": "7  Memory game",
    "section": "7.14 Getting list of relevant files",
    "text": "7.14 Getting list of relevant files\nUse list comprehension to create a list of files of chicken looking left, i.e. with filenames that start with “l”. Use .startswith() to check whether it starts with “l”, store the list in filenames variable. Test your code in a Jupyter Notebook. You should get a list of four files.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#list-operations",
    "href": "07-memory.html#list-operations",
    "title": "7  Memory game",
    "section": "7.15 List operations",
    "text": "7.15 List operations\nOur list consists of four unique filenames but in the game each card should appear twice. There are several ways of duplicating lists. Here, We will use this as a opportunity to learn about list operations. Python lists implement two operations:\n\nAdding two lists together: &lt;list1&gt; + &lt;list2&gt;.\n\n\na = [1, 2, 3]\nb = [4, 5, 6]\na + b\n\n[1, 2, 3, 4, 5, 6]\n\n\nNote that this produces a new list and, therefore, that this is not equivalent to extend method a.extend(b)! The + creates a new list, .extend() extends the original list a.12\n\nList replication:: &lt;list&gt; * &lt;integer-value&gt; creates a new list by replicating the original one &lt;integer-value&gt; times. For example:\n\n\na = [1, 2, 3]\nb = 4\na * b\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\nUse either operation or .extend() method to create the list where each filename is repeated twice. Hint, you can apply list multiplication directly to the filenames list you created via list comprehension (so, replicate it in that same line). Try this code out in a Jupyter Notebook.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#enumerate",
    "href": "07-memory.html#enumerate",
    "title": "7  Memory game",
    "section": "7.16 Looping over both index and item via list enumeration",
    "text": "7.16 Looping over both index and item via list enumeration\nNow that we have a list of filenames, we can create a list of cards out of it. Our dictionary function requires both index and filename. The latter is the item of the list, the former is the index of that item. You could build the index using range() function but Python has a better solution for this: enumerate() function! If, instead of iterating over a list, you iterate over enumerate(), you get a tuple with both (index, value). Here is an example:\n\nletters = ['a', 'b', 'c']\nfor index, letter in enumerate(letters):\n    print('%d: %s'%(index, letter))\n\n0: a\n1: b\n2: c\n\n\nAnd here is how you can use enumerate() for list comprehension.\n\nletters = ['a', 'b', 'c']\n[\"%d: %s\"%(index, letter) for index, letter in enumerate(letters)]\n\n['0: a', '1: b', '2: c']",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#os-library",
    "href": "07-memory.html#os-library",
    "title": "7  Memory game",
    "section": "7.17 Computing path",
    "text": "7.17 Computing path\nOriginally, we specified image file name as \"Images/r01.png\". This did the job but now we have many filenames that we need to join with the folder name to form a path string. On top of that, major operating systems disagree with Windows on where / (forward slash) or \\ (backslash) should be used for paths. To make your code platform-independent and, therefore, more robust, you need to construct a filename string using join function in path submodule. Thus, you can import os library and call it as os.path.join(...) (my personal preference). Or, you can use the same approach as for PsychoPy modules and import path from os, shortening the code. Or, of course, you can even import join directly but I find that lack of library information during use makes things harder to understand (even though the code is even shorter).\njoin takes path components as parameters and joins them to match the OS format. E.g., os.path.join(\"Python seminar\", \"Memory game\", \"memory01.py\") on Windows will return 'Python seminar\\\\Memory game\\\\memory01.py'. As we need to load multiple files, the filename part will vary. However, the folder where the images are located will be the same and, as per usual, it would a good idea to turn it into a formally declared CONSTANT.\nCreate create_card function based on create_card_path so that it assumes that the filename parameter is just the filename without the folder information and, therefore, build the path by join it with the folder name (defined as a constant in the this module!). You now need to drop the \"Images/\" in the value that you pass to it. Test that the code works as before!\n\nCreate create_card in utilities.py. Put updated code into code07.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#a-deck-of-cards",
    "href": "07-memory.html#a-deck-of-cards",
    "title": "7  Memory game",
    "section": "7.18 A deck of cards",
    "text": "7.18 A deck of cards\nLet us put together all the code we need for figuring out cards’ filenames, duplicating them, and creating the cards using filename and index.\nCopy the code for building a duplicated list of filenames that you tested in Jupyter notebook to your main script (code08.py). Then, use enumerate and list comprehension over enumerated duplicate filenames to create cards (plural, replacing your singular card variable) via create_card function you wrote earlier. Update your drawing code to loop over and draw all cards. If your default is \"side\" is \"back\", things will look pretty boring. Change that to ’“front”` to see their faces.\n\nPut your code into code08.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#shuffle",
    "href": "07-memory.html#shuffle",
    "title": "7  Memory game",
    "section": "7.19 Shuffling cards",
    "text": "7.19 Shuffling cards\nWhen you draw cards faces, you will notice that duplicating filenames list produces a very orderly sequence that makes playing the game easy (and boring). We need to shuffle() the filename list before we create cards. Note that shuffle() shuffles list item in place using the fact that the list is mutable. That means you simply call the function and pass the list as an argument. The list gets modified, nothing is returned and nothing need to be assigned back of filenames variable.\n\nPut your code into code09.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#lets-have-a-break",
    "href": "07-memory.html#lets-have-a-break",
    "title": "7  Memory game",
    "section": "7.20 Let’s have a break!",
    "text": "7.20 Let’s have a break!\nWe covered a lot of ground, so it might be a good point to take a break and submit your code for my review.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#adding-main-game-loop",
    "href": "07-memory.html#adding-main-game-loop",
    "title": "7  Memory game",
    "section": "7.21 Adding main game loop",
    "text": "7.21 Adding main game loop\nAt this point, we have a shuffled deck of cards that we show until a player presses a key. Modify the code to have the main presentation loop, similar to one we had when we experimented with PsychoPy stimuli. Previously, we used a logical gameover variable to control the while loop. Here, we will have two reasons to exit the loop: the player pressed an escape key or they won the game. Therefore, let us use a string game_state variable that is initialized to \"running\". Repeat the loop while the game_state is equal to \"running\" but change it \"abort\" if a player pressed escape. You also need to replace waitKeys() with getKeys().\n\nPut your code into code10.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#psychopy-mouse",
    "href": "07-memory.html#psychopy-mouse",
    "title": "7  Memory game",
    "section": "7.22 Detecting a mouse click",
    "text": "7.22 Detecting a mouse click\nIn the game, the player will click on individual cards to turn them over. Before you can use a mouse in PsychoPy, you must create it via mouse = event.Mouse(visible=True, win=win) call, where win is the PsychoPy window you already created. This code should appear immediately below the line where you create the window itself.\nNow, you can check whether the left button was pressed using mouse.getPressed() method. It returns a three-item tuple with True/False values indicating whether each of the three buttons are currently being pressed. Use it the main loop, so that if the player presses left button (its index in the returned list is 0), you change \"side\" of the first card (so, the card with index 0 in the list) to \"front\". This assumes that you initialized card with their \"back\" shown, of course. If you run the code and click anywhere, this should flip the first card.\nPut the mouse-click-processing code before drawing cards. At the moment, it makes no difference but will be useful later on, as it will allow us to draw the latest state of the card (i.e., right after it was flipped by a player).\n\nPut your code into code11.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#position-to-index",
    "href": "07-memory.html#position-to-index",
    "title": "7  Memory game",
    "section": "7.23 Position to index",
    "text": "7.23 Position to index\nCurrently, the first card is flipped if you click anywhere. But the card you flip should be the card the player clicked on. For this we need to implement a function index_from_position that is an inverse of position_from_index. It should take an argument pos, which is a tuple of (&lt;x&gt;, &lt;y&gt;) values (a mouse position within the window), and return an integer card index. You have float values (with decimal points) in the pos argument (because it ranges from -1 to 1 for norm units) and by default the values you compute from them will also be float. However, an index must be integer, so you will need to wrap it in int() function call, before returning it.\nGoing backwards — from position to index — is (IMHO) easier. First, you need to think how you can convert an x coordinate (goes from -1 to 1) to a column index (goes from 0 to 3) given that you have 4 columns (draw a sketch on paper as it will make figuring out math simpler). Similarly, you translate y (from -1 to 1) into row index given that there are only two rows. Once you know row and column index, you can compute the index itself, keeping in mind that there are four card in a row. As with position_from_index, I think it is easier to first play with formulas in a Jupyter Notebook, before turning the code into a function, documenting it, and putting it into utilities.py.\n\nPut index_from_position into utilities.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#flip-a-selected-card-on-click",
    "href": "07-memory.html#flip-a-selected-card-on-click",
    "title": "7  Memory game",
    "section": "7.24 Flip a selected card on click",
    "text": "7.24 Flip a selected card on click\nNow that you have function that returns an index from position (don’t forget to import it), you can flip the card that the player clicked on. For this, you need to extend the card-flipping code inside the if left-mouse button was pressed code. Get the position of the mouse within the window by calling mouse.getPos(). This will return a pair of (x, y) values, which you can pass to your index_from_position() function. This, in turn will return the index of the card the player click on. Change the \"side\" of a card with that index to \"front\". Test the code by turning different cards over, make sure that it is the card that you clicked on that gets turned. And a usual reminder, do not hesitate to put a breakpoint inside the if-statement to check the actual mouse position values and how they are translated into index, if things do not work.\n\nPut your code into code12.py..",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#keeping-track-of-open-cards",
    "href": "07-memory.html#keeping-track-of-open-cards",
    "title": "7  Memory game",
    "section": "7.25 Keeping track of open cards",
    "text": "7.25 Keeping track of open cards\nIn the actual game, a player is allowed to flip only two cards at a time. If they match, they are removed. If not, they are flipped to their backs again. This means we need to keep track of which and how many cards are face up. We can always figure this out by doing a list comprehension scanning for cards that have their \"side\" as \"face\". But, mutable nature of dictionaries presents us with a simpler solution. We create a new list (let us call it face_up) and add cards to it. Dictionaries are mutable, so a reference to the same dictionary object will be present in both lists (same card dictionary will have two stickers on it, one from the cards list, one from face_up list). This way we know which cards are face up (those that are in the list) and we know how many (length of the face_up list).\nHowever, you need to be careful not do add a card more than once (this will mess up our “how many cards are face up” number). There are several ways to do this. Assuming that icard is the index of the card, which you computed via position_to_index() from mouse position, you can simply check whether this card \"side\" is \"front\". Alternatively, you can check whether this card is already in the face_up list. Either way will tell you whether the card is face up. If it is not, you should set its \"side\" to \"front\" and add it to face_up list.\nImplement this code, open a few cards. Then, use a breakpoint to pause the program and check that face_up list contains exactly these (this many) cards. If it has more then your face-up checks do not work. Put a breakpoint on them and step through the code to see what happens.\n\nPut your code into code13.py..",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#opening-only-two-cards",
    "href": "07-memory.html#opening-only-two-cards",
    "title": "7  Memory game",
    "section": "7.26 Opening only two cards",
    "text": "7.26 Opening only two cards\nNow we need to check whether a player opened exactly two cards. In your code, mouse checks should be before the drawing code. This means that cards are drawn face up immediately after a click. Once they are drawn, check the length of face_up, if it equal to 2:\n\npause the program for ~0.5 s13 via wait, so that the player can see both cards.\nflip both cards back (i.e., set their \"side\" to \"back\").\nremove them from face_up list (see .clear() method).\n\n\nPut your code into code14.py..",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#taking-a-matching-pair-off-the-table",
    "href": "07-memory.html#taking-a-matching-pair-off-the-table",
    "title": "7  Memory game",
    "section": "7.27 Taking a matching pair off the table",
    "text": "7.27 Taking a matching pair off the table\nOur code turns cards back even you found a matching pair but we need to take them off the table. Once you have two cards in the face_up list, you need to check whether they have the same chicken on them, i.e., their filenames are the same. If they are, you set \"show\" field to False. If not, you set their \"side\" to \"back\" (what your code is already doing). Either way, you still need to pause the program to allow the player to see them and to clear face_up list (they are either off the table or face down, definitely not face up).\nWe also need to modify our code to handle \"show\" field correctly. First, modify your drawing code to draw only the cards that should be shown. Second, when handling mouse click, you need to check both that the card is not face up and that it is shown (otherwise you can “open” invisible cards).\n\nPut your code into code15.py..",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#game-over-once-all-the-cards-are-off-the-table",
    "href": "07-memory.html#game-over-once-all-the-cards-are-off-the-table",
    "title": "7  Memory game",
    "section": "7.28 Game over once all the cards are off the table",
    "text": "7.28 Game over once all the cards are off the table\nWhen your code works correctly, you can take all the card off the table, so that only the gray screen remains. However, that should be the point when the game finishes and congratulates you on your success. Write a function remaining_cards that will take the list with cards (i.e., our cards list) and will return how many cards are still shown (their \"show\" field is True). You definitely need a for for this but implementation can be very different. You could use an extra counter variable that you initialize to 0 and then increment by one (see += for a shortcut). Alternatively, you can use list comprehensions to filter out all cards that are not shown and return the length of that list (a single line solution). Implement this function in utilities.py and exit the loop by setting game_state to \"victory\". After the loop, you can check the game_state variable and if the player was victorious, show a congratulatory message (TextStim, note that you don’t even need to create a variable for it, you can create an object and call .draw() on it, i.e., visual.TextStim(...).draw()) and wait for a key press before you close the window.\n\nImplement remaining_cards in utilities.py. Put your code into code16.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#do-it-fast",
    "href": "07-memory.html#do-it-fast",
    "title": "7  Memory game",
    "section": "7.29 Do it fast!",
    "text": "7.29 Do it fast!\nThere are different ways on how you can quantify speed in this game. You could look at the number of pairs the player had to open until clearing them up (the fewer, the better). Or, you could measure how fast the player did it in seconds. Or use a combination of these two measures. Let us use the second option — total time taken — as an opportunity to learn about using PsychoPy clocks.\nThe two classes you will be primarily interested in are Clock and CountdownTimer. The only difference between the two is that Clock starts at (and resets to) 0 and start counting elapsed time, so its getTime() method will return only positive values. In contrast, the CountdownTimer start with (and resets to) a value you initialized it with and starts counting remaining time down. Importantly, it will not stop once it reaches 0, so you will eventually end up with negative remaining time. Thus, for Clock you check whether the elapsed time is longer than some predefined value, whereas for CountdownTimer you start at a predefined value and check that the remaining time is above zero. Note it is not guaranteed that the remaining time will be exactly zero. If anything, it is extremely unlikely that this will ever happen, so never test for an exact equality with zero14!\nHere, we are interested in the elapsed time, so Clock is the obvious choice. Create a clock before the game loop and use the elapsed time in the congratulatory message.\n\nPut your code into code17.py.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#how-can-you-improve-it",
    "href": "07-memory.html#how-can-you-improve-it",
    "title": "7  Memory game",
    "section": "7.30 How can you improve it?",
    "text": "7.30 How can you improve it?\nExcellent game but you can always improve it: highscore, multiple round, etc. The sky is the limit!",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "07-memory.html#footnotes",
    "href": "07-memory.html#footnotes",
    "title": "7  Memory game",
    "section": "",
    "text": "The images are courtesy of Kevin David Pointon and were downloaded from OpenClipart. They are public domain and can be used and distributed freely.↩︎\nNot really, but this makes it easier to understand.↩︎\nA metaphor attempt: You can wear different shirts, so your look (variable) changes but each individual shirt (potential values) remains the same (we ignore the wear and tear here) irrespective of whether your are wearing it (value is assigned to a variable) or not.↩︎\nComing up shortly!↩︎\nBuilding on the looks metaphor: You can change your look by using a different (immutable) shirt or by changing your haircut. You hair is mutable, you do not wear a different one on different days to look different, you need to modify it to look different.↩︎\nWell, at least me!↩︎\nIf this makes you want to scream, tell me and will do it together.↩︎\nImmutable values are hashable, whereas mutable ones, like dictionaries and lists, are not. This is because mutable objects can change while the program is running and therefore are unusable as a key. I.e., it is hard to match by a key, if the key can be different by the time you need to access the dictionary.↩︎\nThis function will assume that you provide a full relative path to the file. Later on, we will create a version of this function that will append the folder information itself.↩︎\nUse absolute path only if it is the only option, as it will almost certainly will break your code on another machine.↩︎\nA very arbitrary example!↩︎\nYou will learn about practical implications of this later. For now, keep in mind that seemingly identical output might be fundamentally different underneath.↩︎\nPick the timing you like!↩︎\nMore generally, never compare float values to exact numbers. They are tricky, as the underlying representation does not guarantee that the computation will produce exactly the number that it should: .1 + .1 + .1 == .3 is surprisingly False, try it yourself↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Memory game</span>"
    ]
  },
  {
    "objectID": "08-christmas.html",
    "href": "08-christmas.html",
    "title": "8  Christmas special",
    "section": "",
    "text": "8.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#chapter-concepts",
    "href": "08-christmas.html#chapter-concepts",
    "title": "8  Christmas special",
    "section": "",
    "text": "Building Christmas spirit\nZipping over lists\nLoading setting from JSON or YAML file.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#christmas-tree",
    "href": "08-christmas.html#christmas-tree",
    "title": "8  Christmas special",
    "section": "8.2 Christmas tree",
    "text": "8.2 Christmas tree\nLet us start our Christmas decoration with a Christmas tree. You can download the one I’ve found1 or find an image that you like. Create your basic PsychoPy code to create a window (we will be using Circle later, so think about suitable units), an ImageStim with a tree, draw it and wait for any key press.\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#christmas-tree-decoration",
    "href": "08-christmas.html#christmas-tree-decoration",
    "title": "8  Christmas special",
    "section": "8.3 Christmas tree decoration",
    "text": "8.3 Christmas tree decoration\nFor the decoration, let us use Circle objects of various sizes and color. We could create each one separately with its own custom hard-coded values, but let us instead create three constants that are lists of equal length that describe, respectively position of each ball (BALL_POS would be a good name, each entry should be a tuple of (x, y)), size (BALL_SIZE), and color (BALL_COLOR, stick to \"red\", \"blue\", and \"yellow\", this limited selection of specific colors will be important later when we animate them).\nCreate a list of balls by iterating over these three lists. You have two choices, you can either use an index variable, building an index via range() using len() of one of the lists (they should all be of the same length). But let’s use a cool trick of iterating over a zip() of lists. zip() gives you a tuple combining one element from each list that you can unpack on the fly as in the example below (note that loop variables will receive values in the order that you used for lists).\n\nnumbers = [1, 2, 3]\nletters = [\"A\", \"B\", \"C\"]\nfor  a_number, a_letter in  zip(numbers, letters):\n  print(\"%d: %s\"%(a_number, a_letter))\n\n1: A\n2: B\n3: C\n\n\nYou can zip as many lists as you want. We, obviously, want three. Decide on whether you want to create balls as an empty list and then append each newly created Circle to it in the loop or use list comprehension. Do not forget to draw the balls and think about what you should draw first: the tree or the balls. Experiment with position and sizes to makes it look just perfect.\n\nPut your code into code02.py.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#twinkle-twinkle-little-star",
    "href": "08-christmas.html#twinkle-twinkle-little-star",
    "title": "8  Christmas special",
    "section": "8.4 Twinkle, twinkle, little star",
    "text": "8.4 Twinkle, twinkle, little star\nNow let us make our Christmas balls twinkle, as in the video. The idea is that only one color is “active” at a time. The balls of that color are “on” and balls of other color are “off” (white or gray, or some other color of your liking). Now our display becomes dynamic, so you need to have a game loop and with an opportunity to exit the program by pressing escape.\nFor this, we need to define a list of colors (“red”, “blue”, “yellow”) that we can cycle through and an variable that hold the index of the currently active color (I’ve called it icolor). Every X seconds (I do it every 0.5 seconds, define this as a constant, e.g., TWINKLE_DURATION), increment this index, so that the next color in the list becomes active. Note that you have an out-of-range problem: When you initialize icolor to 0 and increment it by 1 three times, your index is already too large (3, the length of our colors list is 3, so the maximal index is 2). You can either use an if to check for that or you can use a remainder operator % (think about the remainder if you divide any positive value by the length of the colors list).\nOnce you need to update whether balls are “on” or “off”, you need to loop both through the balls and their colors in the original BALLS_COLOR list (when you use a string with color name, it gets translated into an RGB value, so we cannot compare it directly). Again, you can use zip() to loop simultaneously through Christmas balls and their color. If their color matches the active one, their fillColor should be that color. If not, their fillColor should be some “neutral” / “off” color (white? gray?).\nTo keep track of time, you will need a timer variable, use either Clock or CountdownTimer. Once the TWINKLE_DURATION elapsed, update the active color, all the balls, and do not forget to reset the timer.\n\nPut your code into code03.py.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#lets-make-some-noise",
    "href": "08-christmas.html#lets-make-some-noise",
    "title": "8  Christmas special",
    "section": "8.5 Let’s make some noise!",
    "text": "8.5 Let’s make some noise!\nLet add some Christmas music! Download Deck the Halls version by Kevin MacLeod2. For this, we will use sound module of PsychoPy library that generates sounds on the fly and also play audio files in various format such as wav or ogg (but not mp3!). Unfortunately, sound is surprisingly tricky, there are many libraries that might be used by PsychoPy (as of 2023 PsychoPy lists four backends that it might use), and things sometimes break. Thus, if the music does not play for you, ask me and we will try to set your sound libraries up.\nUsing sound is very simple. First, you need to import the Sound class as suggested in the manual:\nfrom psychopy.sound import Sound\nThen, you need a new object of Sound class supplying the file name as the first parameter (I called the variable song). Right before start the loop, you .play() the sound. Note, if you want to play the same sound again, you need to “rewind” it by explicitly calling its .stop() method. For some reason, the sound stops at the end but does not gets “rewind” back, so when you try to play it again and notices that it is already at the end and stops without playing anything.\n\nPut your code into code04.py.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#settings-files",
    "href": "08-christmas.html#settings-files",
    "title": "8  Christmas special",
    "section": "8.6 Settings file formats",
    "text": "8.6 Settings file formats\nSo far, we either hard-coded specific values or defined them as constants (a better of these two approaches). However, this means that if you want to run your game with different settings, you need to modify the program itself. And if you want to have two versions of the game (two experimental conditions), you would need to have two programs with all the problems of maintaining virtually identical code in several places at once.\nA better approach is to have separate files with settings, so you can keep the code constant and alter specific parameters by specifying which settings file the program should use. This is helpful even if you plan to have a single set of setting as it separates code from constants, puts the latter all in one place and makes it easier to edit and check them. There are multiple formats for settings files: XML, INI, JSON, YAML, etc. Our format of the choice for today will be JSON. However, this is a question of taste. Personally, I like YAML for subjective reasons (fewer curly brackets and quotation marks), but you are free to use any format you like. As you will see, this makes little difference for the actual Python code.\n\n8.6.1 XML\nXML — an Extensible Markup Language — looks similar to HTML (HyperText Markup Language). Experiments designed using PsychoPy Builder interface are stored using XML files but with .psyexp extension. A settings file for our Christmas programin XML could look like this\n&lt;Balls&gt;\n  &lt;Ball&gt;\n    &lt;Position&gt;\n      &lt;x&gt;0.1&lt;/x&gt;\n      &lt;y&gt;0.2&lt;/y&gt;\n    &lt;/Position&gt;\n    &lt;Size&gt;0.01&lt;/Size&gt;\n    &lt;Color&gt;red&lt;/Color&gt;\n  &lt;/Ball&gt;\n  &lt;Ball&gt;\n    &lt;Position&gt;\n      &lt;x&gt;0.2&lt;/x&gt;\n      &lt;y&gt;0.1&lt;/y&gt;\n    &lt;/Position&gt;\n    &lt;Size&gt;0.02&lt;/Size&gt;\n    &lt;Color&gt;yellow&lt;/Color&gt;\n  &lt;/Ball&gt;\n  ...\n&lt;/Balls&gt;\n&lt;Timing&gt;\n  &lt;Twinkle duration&gt;0.5&lt;/Twinkle duration&gt;\n&lt;/Timing&gt;\nThe advantage of XML is that it is very flexible yet structured and you can use native Python interface to work with it. However, XML is not easy for humans to read, it is overpowered for our purposes of having a simple set of unique constants and its power means that using it is fairly cumbersome (I use \\ to split a single line into many lines).\nfrom xml.dom import minidom\nsettings = minidom.parse('settings.xml')\n\n# this will give you size of the first ball\nsize = settings.getElementsByTagName(\"Balls\")[0]. \\\n                getElementsByTagName(\"Ball\")[0]. \\\n                getElementsByTagName(\"Size\")[0].firstChild.data\n\n\n8.6.2 INI\nThis is a format with a structure similar to that found in MS Windows INI files.\n[Balls]\n    x = 0.1, 0.2\n    y = 0.2, 0.1\n    size = 0.01, 0.02\n    color = red, yellow\n[Timing]\n    TwinkleDuration = 0.5\nAs you can see it is easier to read and Python has a special configparser library to work with them. The object you get is, effectively, a dictionary with additional methods and attributes. However ConfigParser does not try to guess the type of data, so all values are stored as strings and it is your job to convert them to whatever type you need, e.g., integer, list, etc.\nimport configparser\nsettings = configparser.ConfigParser()\nsettings.read('settings.ini')\nsettings['Balls']['size'] # this will give you a string '0.01, 0.02'\n\n\n8.6.3 JSON\nJSON (JavaScript Object Notation) is a popular format to serialize data for web applications that use it to exchange data between a server and a client.\n{\n  \"Balls\": {\n    \"position\": [[0.1, 0.2], [0.2, 0.1]],\n    \"size\": [0.01, 0.02],\n    \"color\": [\"red\", \"yellow\"]\n  },\n  \"Timing\": {\n    \"Twinkle duration\" : 0.5\n  }\n}\nYou can parse any string in JSON format into a dictionary in Python using json module. Its advantage over INI files is that JSON explicitly specifies data type (i.e., strings are in quotation marks), so it converts it automatically. Note that unlike configparse, json module does not work with files directly, so you need to open it manually (ignore the with magic for a moment, you will learn about it in detail when we will talk about context managers).\nimport json\nwith open('settings.json') as json_file:\n    settings = json.load(json_file)\n    \nsettings[\"Balls\"][\"size\"] # this will give a list [0.01, 0.02]\n\n\n8.6.4 YAML\nYAML (YAML Ain’t Markup Language, rhymes with camel) is very similar to JSON but its config files are more human-readable. It has fewer special symbols and curly brackets but, as in Python, you must watch the indentations as they determine the hierarchy.\nBalls:\n  position: [[0.1, 0.2], [0.2, 0.1]]\n  size: [0.01, 0.02]\n  color: [\"red\", \"yellow\"]\nTiming:\n  Twinkle duration : 0.5\nYou will need to install a third-party library pyyaml to work with YAML files. You get the same dictionary as for the JSON\nimport yaml\nwith open(\"settings.yaml\") as yaml_stream:\n    settings = yaml.safe_load(yaml_stream)\n    \nsettings[\"Balls\"][\"size\"] # this will give a list [0.01, 0.02]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#using-settings",
    "href": "08-christmas.html#using-settings",
    "title": "8  Christmas special",
    "section": "8.7 Using settings",
    "text": "8.7 Using settings\nLook at your code04.py and identify constants and hard-coded values that you should put into a settings file. E.g., definitely constants that describes Christmas balls and twinkle duration but, possibly, also the size of the window, name of the Christmas tree and song files, etc. In general, I put every such value into settings even if it used only once (as with the size of the window) because then I know that all constants are the settings file. This way there is a single, nicely organized place to check and I do not need to search through the code to figure a specific value out.\nOnce you transferred all your constants into the settings file (use either JSON or YAML), add the code that loads it at the very beginning and use settings dictionary in place of constants.\n\nPut your code into code05.py.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#merry-christmas-and-a-happy-new-year",
    "href": "08-christmas.html#merry-christmas-and-a-happy-new-year",
    "title": "8  Christmas special",
    "section": "Merry Christmas and a Happy New Year!",
    "text": "Merry Christmas and a Happy New Year!",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "08-christmas.html#footnotes",
    "href": "08-christmas.html#footnotes",
    "title": "8  Christmas special",
    "section": "",
    "text": "Created by isaiah658.↩︎\nDeck the Halls B by Kevin MacLeod http://incompetech.com Creative Commons — Attribution 4.0 International — CC BY 4.0 Free Download / Stream: https://bit.ly/deck-the-halls-b Music promoted by Audio Library https://youtu.be/RzjZ-WdVeyk↩︎",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Christmas special</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html",
    "href": "09-flappy-bird.html",
    "title": "9  Flappy Bird",
    "section": "",
    "text": "9.1 Chapter concepts\nWe will use this game as an opportunity to learn more about object-oriented programming. You already know how to use classes, now you get to create them and see how it makes your life easier.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#chapter-concepts",
    "href": "09-flappy-bird.html#chapter-concepts",
    "title": "9  Flappy Bird",
    "section": "",
    "text": "Object-oriented programming\nComputed properties of objects: @property",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#object-oriented-programming",
    "href": "09-flappy-bird.html#object-oriented-programming",
    "title": "9  Flappy Bird",
    "section": "9.2 Object-oriented programming",
    "text": "9.2 Object-oriented programming\nThe core idea is in the name: Instead of having variables/data and functions separately, you combine them in an object that has attributes/properties (its own variables) and methods (functions). This approach uses our natural tendency to perceive the world as a collection of interacting objects and has several advantages that I will discuss below.\n\n9.2.1 Classes and objects (instances of classes)\nBefore we continue, I need to make an important distinction between classes and objects1. A class is a “blue print” that describes properties and behavior (methods) of objects of that class. This “blue print” is used to create an instance of that class, which is called an object. For example, Homo sapiens is a class that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class only has a concept of height but no specific height itself. E.g., you cannot ask “What is height of Homo sapiens?” only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say “Run, Homo sapiens! Run!” as abstract concepts have trouble with real actions like that. Instead, it is Alexander Pastukhov who is an instance of Homo sapiens class with a specific (average) height and a specific (below average) ability to run. Other instances of Homo sapiens (other people) will have different height and a different (typically better) ability to run. Thus, class describes what kind of properties and methods objects have. This means that whenever you meet a Homo sapien, you could be sure that they have height. However, individual objects have different values for various properties and so calling their methods (asking them to perform certain actions) may result in different outcomes.\nAnother, a more applied, example would be your use of ImageStim class to create multiple instances of front side of a card in Memory game. Again, the class defines properties (image, pos, size, etc.) and methods (e.g., method draw()) that individual objects will have. You created these objects to serve as front side of cards. You set different values for same properties (image, pos) and that ensured that when you call their method draw(), each card was drawn at its own location and with it own image.\n\n\n9.2.2 Encapsulation\nPutting all the data (properties) and behavior (methods) inside the class simplifies programming by ensuring that all relevant information can be found in its definition. Thus, you have a single place that should hold everything that defines object’s behavior. Contrast this with our approach in previous seminars where cards as dictionaries were separate from functions that created them. Today, you will see how encapsulating everything into classes turns this mess into a simpler and easier-to-understand code.\n\n\n9.2.3 Inheritance / Generalization\nIn object-oriented programming, a class can be derived from some ancestor class and thus inherit its properties and methods. Moreover, several classes can be derived from a single ancestor producing a mix of unique and shared functionality. This means that instead of rewriting the same code for each class, you can define a common code in an ancestor class and focus on differences or additional methods and properties in descendants.\nUsing the Homo sapiens example from above. Humans, chimpanzees and gorillas are all different species but we share a common ancestor. Hence, we are different in many respect, yet, you could think about all of us as “apes” that have common properties such as binocular trichromatic vision. In other words, if you are interested in color vision, you do not care what specific species you are looking it, as all apes are (roughly) the same in that respect. Or, you can move further down the evolution tree and think about us as “mammals” that, again, have common properties and behavior, such as thermoregulation and lactation. Again, if you are interested only in whether an animal has thermoregulation, knowing that it is a mammal is enough.\nSimilarly, in PsychoPy various visual stimuli that we used (ImageStim, TextStim, Rect) have same properties (e.g., pos, size, etc.) and methods (most notably, draw()). This is because they are all descendants from a common ancestor BaseVisualStim that defines their common properties and methods2. This means that you can assume that any visual stimulus (as long as it descends from BaseVisualStim) will have size, pos, ori and can be drawn. This, in turn, means that you can have a list of various PsychoPy visual stimuli and move or draw all of them in a single loop without thinking which specific visual stimulus you are moving or drawing. Also note that you cannot assume these same properties for sound stimuli because they are not descendants of BaseVisualStim but of _SoundBase class.\nThere are other ways of achieving common behavior (generalization) in Python without orderly inheritance, such as “duck typing”3 or mixins but this will be a topic of another chapter.\n\n\n9.2.4 Polymorphism\nAs you’ve learned in the previous section, inheritance allows different descendants to share common properties and behavior, so that in certain cases you can view them as being equivalent to an ancestor. E.g., any visual stimulus (a descendant of BaseVisualStim class) can be drawn, so you just call its draw() method. However, it is clear that these different stimuli implement drawing differently, as the Rect stimulus looks different from the ImageStim or TextStim. This is called “polymorphism” and the idea is to keep the common interface (same draw() call) while abstracting away the actual implementation. This allows you to think about what you want an object to do (or what to do with an object), instead of thinking how exactly it is implemented.\n\n\n9.2.5 A minimal class example\nEnough of the theory, let us see how classes are implemented in Python. Here is a very simple class that has nothing but the constructor __init__() method, which is called whenever a new object (class instance) is created, and a single attribute / property total.\nclass Accumulator:\n    \"\"\"\n    Simple class that accumulates (sums up) values.\n\n    Attributes\n    ----------\n    total : float\n        Total accumulated value\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor, initializes the total value to zero.\n        \"\"\"\n        self.total = 0\n        \n# here we create an object number_sum, which is an instance of class Accumulator.\nnumber_sum = Accumulator()\nprint(number_sum.total)\nLet’s go through it line by line. First line class Accumulator: shows that this is a declaration of a class whose name is Accumulator. Note that the first letter is capitalized. This is not required per se, so Python police won’t be knocking on your door if you write it all in lower or upper case. However, the general recommendation is that class names are written using UpperCaseCamelCase whereas object (instances of the class) names are written using lower_case_snake_case. This makes distinguishing between classes and objects (instances of classes) easier, so you should follow this convention.\nThe definition of the class are the remaining indented lines. As with functions or loops, it is the indentation that defines what is inside and what is outside of the class. The only method we defined is def __init__(self):. This is a special method4 that is called when an object (instance of the class) is created. This allows you to initialize the object based on parameters that were passed to this function (if any). You do not call this function directly, rather it is called whenever an object is created, e.g., number_sum = Accumulator() (last line). Also, it does not return any value explicitly via return. Instead, self (the very first parameter, more on it below) is returned automatically.\nAll class methods (apart from special cases we currently do not concern ourselves with) must have one special first parameter that is the object itself. By convention it is called self5. It is passed to the method automatically, so whenever you write square.draw() (no explicit parameters written in the function call), the actual method still receives one parameter that is the reference to the square variable whose method you called. Inside a method, you use this variable to refer to the object itself.\nLet us go back to the constructor __init()__ to see how you can use self. Here, we add a new persistent attribute/property to the object and assign a value to it: self.total = 0. It is persistent, because even though we created it inside the method, the mutable object is passed by reference and, therefore, we assigned it to the object itself. Now you can use this property either from inside self.total or from outside number_sum.total. You can think of properties as being similar to field/value pairs in the dictionary we used in Memory game but for syntax: object.property versus dictonary[\"field\"]6. Technically, you can create new properties in any method or even from outside (e.g., nothing prevents you from writing number_sum.color = \"red\"). However, this makes understanding the code much harder, so the general recommendation is to create all properties inside the constructor __init__() method, even if this means assigning None to them7.\n\n\n9.2.6 add method\nLet us add a method that adds 1 to the total property.\nclass Accumulator:\n    ... # I am skipping all previous code here\n    \n    def add(self):\n        \"\"\"\n        Add 1 to total\n        \"\"\"\n        self.total += 1\nIt has first special argument self that is the object itself and we simply add 1 to its total property. Again, remember that self is passed automatically whenever you call the method, meaning that an actual call looks like number_sum.add().\nCreate a Jupyter notebook (you will need to submit it as part of the assignment) and copy-paste the code for Accumulator class, including the .add() method. Create two objects, call them counter1 and counter2. Call .add() method twice for counter2 and thrice for counter1 (bonus: do it using for loop). What is the value of the .total property of each object? Check it by printing it out.\n\nCopy-paste and test Accumulator class code in a Jupiter notebook.\n\n\n\n9.2.7 Flexible accumulator with a subtract method\nNow lets us create a new class that is a descendant of the Accumulator. We will call it FlexibleAccumulator as it will allow you to also subtract from the total count. You specify ancestors (could be more than one!) in round brackets after the class name\nclass FlexibleAccumulator(Accumulator):\n    pass # You must have at least one non-empty line, and pass means \"do nothing\"\nNow you have a new class that is a descendant of Accumulator but, so far, is a perfect copy of it. Add subtract method to the class. It should subtract 1 from the .total property (don’t forget to document it!). Check that it works. Create one instance of Accumulator and another one of FlexibleAccumulator class and check that you can call add() on both of them but subtract() only for the latter.\n\nAdd subtract method to the FlexibleAccumulator class in a Jupiter notebook. Add testing.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#method-arguments",
    "href": "09-flappy-bird.html#method-arguments",
    "title": "9  Flappy Bird",
    "section": "9.3 Method arguments",
    "text": "9.3 Method arguments\nNow, create a new class SuperFlexibleAccumulator that will be able to both add() and subtract() an arbitrary value. Think about which class it should inherit from. Redefine both .add() and .subtract() method in that new class by adding value argument to both method and add/subtract this value rather than 1. Note that now you have two arguments in each method (self, value) but when you call you only need to pass the latter (again, self is passed automatically). Don’t forget to document value argument (but you do not need to document self as its meaning is fixed).\n\nCreate SuperFlexibleAccumulator class and define super flexible add and subtract methods that have value parameter ( in a Jupiter notebook). Test them!\n\n\n9.3.1 Constructor arguments\nAlthough constructor __init(...)__ is special, it is still a method. Thus, you can pass arguments to it just like you did it for other methods. You pass these arguments when you create an object, so in our case, you put it inside the bracket for counter = SuperFlexibleAccumulator(...).\nModify the code so that you pass the initial value that total is set to, instead of zero.\n\nAdd [initial_value] parameter to the constructor of the SuperFlexibleAccumulator class in a Jupiter notebook. Test it!\n\n\n\n9.3.2 Calling methods from other methods\nYou can call a function or object’s method at any point of time, so, logically, you can use methods inside methods. Let’s modify our code, realizing that subtracting a value is like adding a negative value. Modify your code, so that .subtract() only negates the value before passing it to .add() for actual processing. Thus, total is modified only inside the add() method.\n\nModify subtract() method of SuperFlexibleAccumulator to utilize add() in a Jupiter notebook. Test it!\n\n\n\n9.3.3 Local variables\nJust like normal functions, you methods can have local variables. They are local (visible and accessible only from within the method) and are not persistent (their values do not survive between the calls). Conceptually, you separate variables that need to be persistent (retain their value the whole time object exists) as attributes/properties and temporary variables that are need only for the computation itself as local method variables. What would be value of property .total in this example:\nclass Accumulator:\n    def __init__(self, initial):\n        temp = initial * 2\n        self.total = initial\n        \ncounter = Accumulator(1)\nWhat about in this case?\nclass Accumulator:\n    def __init__(self, initial):\n        temp = initial * 2\n        self.total = temp\n        \ncounter = Accumulator(1)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#flappy-bird-the-humble-beginnings",
    "href": "09-flappy-bird.html#flappy-bird-the-humble-beginnings",
    "title": "9  Flappy Bird",
    "section": "9.4 Flappy Bird: the humble beginnings",
    "text": "9.4 Flappy Bird: the humble beginnings\nWe will start with a basic scaffolding for our program. Download the bird image8 and put it into a folder where you will store the code. Create a basic code that uses settings file that defines minimal setting for a window (size) and a bird (image file). Organize it hierarchically, as follows, as this will help us keep settings for different classes organized.\n{\n  \"Bird\": {\n    \"Image\" : \"Blue-Bird.png\"\n  },\n  \"Window\": {\n    \"Size\": [800, 600]\n  }\n}\nCreate a window using this specified size and an ImageStim using the filename from the settings file. Add a basic game loop in which you repeatedly draw the bird (should appear right at the center of the screen) and check for a key press (escape should exit the game).\n\nPut your code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#flappy-bird-class",
    "href": "09-flappy-bird.html#flappy-bird-class",
    "title": "9  Flappy Bird",
    "section": "9.5 Flappy Bird class",
    "text": "9.5 Flappy Bird class\nOur flappy bird is, effectively, an image but we would like it to have additional behaviors, like, automatically falling down due to gravity, flying up due to flapping its wings, etc. There are several way we can do this. We can keep the image in ImageStim and write additional functions to handle it (the way we did previously). We could create an new class FlappyBird that will have the ImageStim as its attribute. Or, we could utilize the power of inheritance and build FlappyBird class on top of the ImageStim. This means less work for us, so that is the path we will follow.\nCreate a new file that will contain your FlappyBird class. Here is how it should look like:\n\"\"\"Your comment on what this file contains.\n\"\"\"\n# import libraries, which ones do you need?\n\nclass FlappyBird(visual.image.ImageStim):\n  \"\"\"\n  FlappyBird class based on ImageStim\n  \"\"\"\n  def __init__(self, win, settings):\n    \"\"\"\n    Constructor.\n    \"\"\"\n    super().__init__(win, image=settings[\"Image\"])\nIn the code above, I defined FlappyBird as a descendant of the ImageStim9. To make the latter work, we need to initialize it properly by calling it constructor. This is what super().__init__(...) call does: Calls constructor of the ancestor class (super() refers to the immediate ancestor) to enable all the magic that we want to reuse. Recall that ImageStim needs at least two parameters: a PsychoPy window that the stimulus will belong to and an image (a filename in this case). Here, I assume that when I create a bird object (call the constructor), I pass two parameters (again, self comes “for free”, so you do not pass it explicitly but assume that it is the first argument that you get): the [window]((https://psychopy.org/api/visual/window.html#psychopy.visual.Window) that we created plus a dictionary with settings for the bird (there will be more settings, so it would be practical to pass the whole dictionary instead of passing one parameter at a time).\nCopy paste that code (plus add appropriate imports and comments) and use FlappyBird class instead of ImageStim. Note that FlappyBird inherits all its functionality from ImageStim, so, apart from how you create it, you can use it in exactly the same way. Meaning, you do not need to modify anything else in your code (told you, it would save us time and effort!).\n\nPut FlappyBird class code into a separate file. Use it instead of ImageStim in code02.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#a-properly-sized-bird",
    "href": "09-flappy-bird.html#a-properly-sized-bird",
    "title": "9  Flappy Bird",
    "section": "9.6 A properly-sized bird",
    "text": "9.6 A properly-sized bird\nOur bird is very cute but is way too large. Add a new setting for it (I suggest calling is Size and setting it to 0.1) and then use it inside the constructor adding size=... to super().__init__ call. Do you need to change anything in the main code?\n\nAdd bird size setting. Use it in FlappyBird class constructor.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#flappy-bird-is-falling-down-my-dear-lady",
    "href": "09-flappy-bird.html#flappy-bird-is-falling-down-my-dear-lady",
    "title": "9  Flappy Bird",
    "section": "9.7 Flappy Bird is falling down (my dear lady)",
    "text": "9.7 Flappy Bird is falling down (my dear lady)\nBefore our bird flies, it needs to learn how to fall down. Falling down is just a change of bird’s vertical position based on bird’s vertical speed. We already have a property for the (horizontal and) vertical position: self.pos, a tuple with (x, y) position of the center of the image. But we do need an additional new attribute that would encode bird’s vertical speed. Create it in the constructor (if you forgot how to do it, take a look above on how we create the total attribute for Accumulator class) and call it vspeed. Also, create a new setting (I would call it \"Initial vertical speed\") and set it to -0.01, use this setting in the constructor to initialize vspeed.\nNow we also need a method that would update bird’s position based on its (current) speed. Create this method below the constructor (does it need any parameters beyond compulsory self?). It should simply compute \\(y_{new} = y + vspeed\\) and assign \\(y_{new}\\) back to pos attribute (note that you cannot assign only y coordinate, you have to pass the tuple (x, y) reusing original x value from pos). Do not forget to document the new method!\nNow you need to call the update_per_frame() on each frame before drawing the bird. This should make your bird fall of the screen! (Experiment with \"Initial vertical speed\" setting to make it fall faster or slower or even upwards!)\n\nUpdate FlappyBird class. Use update_per_frame method in code03.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#timing-the-fall",
    "href": "09-flappy-bird.html#timing-the-fall",
    "title": "9  Flappy Bird",
    "section": "9.8 Timing the fall",
    "text": "9.8 Timing the fall\nCurrently, the speed of our bird’s fall is measured in norm units per frame. This works but these are not the most convenient units to think in. Plus, it relies on PsychoPy (and the rest of our code) to ensure that time between individual frames is exactly the same. This is mostly the case and an occasionally slow bird is not a big problem for a game. However, that might be a problem for an actual experiment that requires precise timing of movement. Thus, we need to think about vertical speed in units of norm units per second and measure time between calls ourselves.\nCreate a new Clock attribute that will count the time elapsed since it last reset (I would call it frame_timer). Create an update() method to compute \\(y_{new} = y + vspeed * T_{elapsed}\\), where \\(T_{elapsed}\\) is the time elapsed between frames. Do not forget to reset the timer! (What will happen if you do forget?)\nNow set your \"Initial vertical speed\" to some reasonable value (e.g., 0.5) and check that the time it takes for the bird to fall of the screen looks reasonable (for 0.5 norm units / second it should be off the screen in two seconds).\n\nUpdate FlappyBird class with a timer and update method. Use update instead of update_per_frame in code04.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#it-is-all-newtons-fault",
    "href": "09-flappy-bird.html#it-is-all-newtons-fault",
    "title": "9  Flappy Bird",
    "section": "9.9 It is all Newton’s fault",
    "text": "9.9 It is all Newton’s fault\nNow let us add gravity, so that the speed of falling would be constantly changing. Create a new setting and call it \"Gravity\". Set it to -0.5 (units are norm units per second squared) but experiment with different values later on. Acceleration due to gravity changes vertical speed just like speed itself changes the vertical position10. Update your update method to change the speed based on acceleration given the elapsed time. What do you need to update first, the speed or the location? Also, think about how you will store the acceleration: It is in settings parameter that exists only in the constructor. You can either store it in a new attribute or store all settings in an attribute for later use.\n\nUpdate FlappyBird class with acceleration due to gravity.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#flap-bird-flap",
    "href": "09-flappy-bird.html#flap-bird-flap",
    "title": "9  Flappy Bird",
    "section": "9.10 Flap bird, flap!",
    "text": "9.10 Flap bird, flap!\nLet us add ability of the bird to “flap” in order to stay in the air. First, create a new setting Flap speed and set it to 0.4 (as usual, feel free to experiment!). Add a new method .flap(self) and inside simply set vspeed to Flap speed. Thus, a single flap sets the bird flying up with Flap speed speed which, however, will be constantly reduced by the acceleration due to Gravity so the bird will eventually start falling down again.\nIn the main code, check for \"escape\" and \"space\" keys. If the latter is pressed, call .flap() method of the bird. Check that you can keep the on the screen by timing the space button presses or can make it fly upwards off the screen.\n\nAdd flap method to FlappyBird class. Use it in code04.py whenever player presses space.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#stay-off-the-ground",
    "href": "09-flappy-bird.html#stay-off-the-ground",
    "title": "9  Flappy Bird",
    "section": "9.11 Stay off the ground",
    "text": "9.11 Stay off the ground\nIn our game, the player can lose either if they hit an obstacle (we do not have any yet) or if the bird drops below the ground level, i.e., the bottom edge of the window. Create a new method is_airborne() that will return True if y position of the bird is above -1 (note, you do not need an explicit if for this, nor do you need to write True or False anywhere, think how this can be done without these).\nIn the main loop add the check for bird.is_airborne() condition so that it continues until player presses \"escape\" or the bird hits the ground.\n\nAdd is_airborne method to FlappyBird class. Use it in code06.py as an additional condition for the game loop.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#computed-attribute-property",
    "href": "09-flappy-bird.html#computed-attribute-property",
    "title": "9  Flappy Bird",
    "section": "9.12 Computed attribute @property",
    "text": "9.12 Computed attribute @property\nAs was explained the in “Object-oriented programming” section above, properties describe state of an object, whereas methods describe what an object can do or what you do to an object. Our is_airborne() method breaks this logic: It describes the state of the bird but we call it (use it) as a method. What we have here is a computed property that is inferred from other properties of an object. In our case, we infer property is_airborne from y. We could, of course, make is_airborne into a real property by defining it in the constructor and then updating it inside update() method. However, we will instead use a cool feature called decorators to turn a method into a read-only property. The only thing you need to do is to add @property decorator right above the def is_airborne(self): line and drop brackets when using it in the main loop (so just bird.is_airborne instead of bird.is_airborne()).\n@property tells Python that the method right below will (must!) return a value and that outside world should see it not as a method but as a property. You can use it to make properties read-only, so that they could not be (easily) changed from outside or to create properties that are computed on-the-fly as in our example.\nNote that difference is not so much of practical implementation (changes we made to the code were minimal) but of a conceptual nature: Object’s states should be properties not methods. In our small example this may look like an overkill but in a moderately complex project even small conceptual blurring of lines could make it harder to understand the code.\n\nTurn is_airborne into a property. Use it as property in code07.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#an-opening-in-an-obstacle",
    "href": "09-flappy-bird.html#an-opening-in-an-obstacle",
    "title": "9  Flappy Bird",
    "section": "9.13 An opening in an obstacle",
    "text": "9.13 An opening in an obstacle\nWe aim of the game is for the bird to fly avoiding obstacles. An obstacle consist of two rectangle, one that protrudes from above and another one from below. The opening between them gives the bird an opportunity to fly through. So let us begin by writing a code (in the Jupyter notebook) that would generate a random opening, characterized by y_bottom and y_top based on four parameters:\n\nlower_margin : lowest possible position of the bottom of the opening relative to the bottom of the screen, i.e., the y_bottom cannot be closer to -1 than that.\nupper_margin : higher possible position of the top of the opening relative to the top of the screen, i.e., the y_top cannot be closer to 1 than that.\nmin_size : the minimal size of the opening, i.e., minimal distance between y_top and y_bottom.\nmax_size : the maximal size of the opening, i.e., maximal distance between y_top and y_bottom.\n\nWrite a code that assume certain values for each parameter (e.g., lower_margin = 0.2, upper_margin = 0.2, min_size = 0.2, max_size = 0.4) and generates a random pair (y_bottom, y_top) that satisfies the conditions.\n\nWrite a random opening code in a Jupiter notebook.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#an-obstacle",
    "href": "09-flappy-bird.html#an-obstacle",
    "title": "9  Flappy Bird",
    "section": "9.14 An obstacle",
    "text": "9.14 An obstacle\nNow let us create an Obstacle class (put it into a separate file). It will consist of two rectangles, one protruding from the top and the other one from the bottom, with a random opening in between. At the moment you need six settings to describe an Obstacle: The four parameters that define a random opening plus a width of rectangles and their color. Describe them as a separate group in the settings files (probably under \"Obstacles\") and pass them to the constructor of the Obstacle class.\nIn the constructor, generate a random opening (you have the code for this already) and create the two rectangles both width wide, one going from the top till y_top, another one from the bottom till y_bottom. Place both horizontally at the right edge of the window but so you could see them. Decide on how you will store the two rectangles, you can put them into two different attributes (e.g., upper_rect and lower_rect) or have them in a list. I would suggest the latter approach, as it will simplify your future code. Think about which parameters you need for the __init__() constructor function.\nYou also will need a draw() method that simply draws both rectangles. Implement the class in a separate file, then create and draw a single obstacle in the main code to check that it looks right.\n\nCreate Obstacle class in a separate file. Use it in code08.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#a-moving-obstacle",
    "href": "09-flappy-bird.html#a-moving-obstacle",
    "title": "9  Flappy Bird",
    "section": "9.15 A moving obstacle",
    "text": "9.15 A moving obstacle\nConceptually, our bird fly towards an obstacle but instead we will induce perception of its motion by moving obstacles from right to left. Define a new speed setting for an Obstacle class, it should be in norm units per second and create an update method that would change horizontal position of both rectangles based on the amount of time that passed between the calls. This is similar to how we updated bird’s position based on its speed, so follow the same logic and think about which additional attributes you require and how you store and use any relevant information.\nCall update() at the same place that you update bird’s location in the main loop and check that the obstacle is moving from right to left.\n\nAdd update method to Obstacle class. Use it in code09.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#hitting-the-wall",
    "href": "09-flappy-bird.html#hitting-the-wall",
    "title": "9  Flappy Bird",
    "section": "9.16 Hitting the wall",
    "text": "9.16 Hitting the wall\nAt the moment, our bird is flying through the obstacle like it is not there. But it is! Luckily for us, PsychoPy makes implementing this very easy, as it can check whether two stimuli overlap using overlaps() method of one of them (and the second stimulus is passed as an argument).\nThus, to check whether the bird hit the wall, we just need to create a method (let us call it check_if_hit) in an Obstacle class that will take a bird object and check whether it overlaps() with one of the rectangles. Remember, our FlappyBird is a descendant of the ImageStim, so we can pass it to the overlaps() method directly (advantage of using the inheritance!)\nIn the main game loop, add the check for the bird not hitting the obstacle to the main condition (so now you should have three things to check for). Test your code by flying the bird into the wall. Also, by flying your bird through the opening. Note that if our settings make it too tricky, modify them to make the opening larger.\n\nAdd check_if_hit method to Obstacle class. Use it in code10.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#an-obstacle-manager",
    "href": "09-flappy-bird.html#an-obstacle-manager",
    "title": "9  Flappy Bird",
    "section": "9.17 An obstacle manager",
    "text": "9.17 An obstacle manager\nA game with a single obstacle is no fun but before we add more, we need a class that will manage them for us. Let us call it ObstaclesManager. For the moment, it will simply wrap up all functionality that we implemented in the main script. In the constructor, it should create a list attribute for obstacle objects and add a first one, it should also implement methods draw(), update(), and check_if_hit() that draws, updates, and checks for an overlap with a bird for all obstacles on the list. For the moment we will still have just one of them in the list but implementing things in the loop means it will be easier to add more. Create the class and then use it in the main script.\nThere should be no actual changes of how the game plays, just the code refactoring. However, it helps us to hide the management part from the main script (making it easier to understand) and, if you did everything correctly, the code should “just work” once you replace Obstacle with ObstaclesManager object.\n\nCreate ObstaclesManager class. Use it in code11.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#loads-of-obstacles",
    "href": "09-flappy-bird.html#loads-of-obstacles",
    "title": "9  Flappy Bird",
    "section": "9.18 Loads of obstacles",
    "text": "9.18 Loads of obstacles\nNow we are ready to add more obstacles. You need to update the update method of the ObstaclesManager so that it adds a new obstacle to the list after a random time interval. Define a new setting Spawn time, a list of two values that define a minimal and maximal time between spawns, and create a CountdownTimer (or a Clock, remember they differ only in whether time is subtracted or added) attributed. Whenever the timer is up, add a new obstacle to the list, generate a new delay, and set the timer again. Note that now you need settings and a Window in the update because they are required for creating a new obstacle. Think how you can store them for later use in the constructor.\nDo you need to change anything in the main script? Check that more obstacles appear over time!\n\nUpdate update of the ObstaclesManager class.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#removing-redundant-obstacles",
    "href": "09-flappy-bird.html#removing-redundant-obstacles",
    "title": "9  Flappy Bird",
    "section": "9.19 Removing redundant obstacles",
    "text": "9.19 Removing redundant obstacles\nOnce the obstacle is past the left edge of the screen (its x-axis position is less than -1) we need to remove it from the list. Otherwise, we will waste a lot of time and memory keeping track and drawing obstacles that are neither relevant, nor visible. Think about how you would implement this before reading further.\nFirst, we need to compute the horizontal position of an obstacle. You can deduce it from pos attribute of one of the rectangles and implement this use of attribute (pos of Obstacle) of an attribute (obstacles of ObstaclesManager) directly. However, working with attributes of attributes makes code harder to read and to maintain. Instead, add a new computed property x to Obstacle class that would return a single number (horizontal position) using @property decorator we used for the bird’s is_airborne dynamic attribute.\nUpdate the update method of the ObstaclesManager to check the position the first obstacle in the list. If it less than -1, simply pop it from the list. Why the first one? Because any other obstacle in the list was added later and, therefore, must be further to the right. Why only the first one? If we assume both a reasonable motion speed and a reasonable spawn delay, it is very unlikely that more than one obstacles reaches the left edge at the same time.\nNote that for safety reasons, you must first check that the obstacles attribute is not empty! Hint, when used in a conditional statement directly, empty list evaluates to False. Debug the code to make sure that obstacles are indeed removed. You can either use a different cut-off point (e.g., -0.25) to see that easier or put a break point at the line that pops the redundant obstacle (better still, do both!)\n\nUpdate update of the ObstaclesManager class.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#keeping-the-score",
    "href": "09-flappy-bird.html#keeping-the-score",
    "title": "9  Flappy Bird",
    "section": "9.20 Keeping the score",
    "text": "9.20 Keeping the score\nIt is hard to brag about your bird-flying skills, if you do not how many obstacles did you fly through. Let us add the score! First, create a TextStim (call it score_text) and put it somewhere one the screen, e.g., a top-left or top-right corner. Initialize its text to \"0\". Draw it in the main loop. Make sure it works before you continue.\nTo keep the score, we need to count the number of obstacles that the bird clears on every frame and add it to the total score. As with the removal of redundant obstacles, it will be either zero or one obstacle that crossed the middle of the screen. But in this case, it is not the leftmost that we have to check but the leftmost among those that did not yet cross the mid-line. There are different way you can approach this, so think how you would approach this before reading on. And if you came up with a different plan, by all means – implement it!\nMy way of doing this is to introduce a new attribute scored = False and a method score() to the Obstacle class. In the score() method, if the object crossed the 0 line and has not been scored, it marked as scored and the method returns 1. Otherwise, the object was either already scored or did not cross the mid-line yet, so it returns 0. Next, I added a score() method to the ObstaclesManager that simply computes the total score (sum of) scores of all obstacles in the list. In the main script this score is added to a score variable that, in turn, is used to update score_text.\n\nUpdate your code and use it in code12.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#a-foundation",
    "href": "09-flappy-bird.html#a-foundation",
    "title": "9  Flappy Bird",
    "section": "9.21 A foundation",
    "text": "9.21 A foundation\nThis is just a foundation of a game, so feel free to add to it. Animated bird? Difficulty levels? Different kinds of obstacles? High-score table?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "09-flappy-bird.html#footnotes",
    "href": "09-flappy-bird.html#footnotes",
    "title": "9  Flappy Bird",
    "section": "",
    "text": "No, it is not déjà vu, I am repeating myself to remind you about the distinction.↩︎\nBaseVisualStim does not actually define draw() method, only that it must be present.↩︎\nYes, it is really called “duck typing”.↩︎\nThere are more special methods that you will learn about later, they all follow __methodname__() convention.↩︎\nAgain, you can use any name for that parameter but that will surely confuse everyone.↩︎\nThis is actually how all properties and methods are stored, in a __dict__ attribute, so you can write number_sum.__dict__[\"total\"] to get it.↩︎\nIf you use a linter, it will complain whenever it sees a property not defined in the constructor↩︎\nCreated by Madison Kingsford.↩︎\nNote that even though you can import ImageStim from visual, it is a better idea to specify its submodule for inheritance: visual.image.ImageStim. Inheritance will work for ImageStim even without that extra .image bit but won’t work for some other stimuli due to so-called “laze loading” of classes. For these other classes, like Rect, you will get a very mysterious sounding error message, so it is better to always use full paths to the class when inheriting from them. You can find the full path in the “Details” section of documentation. E.g., the full path for Rect class is psychopy.visual.rect.Rect↩︎\nI.e., speed is a derivative of position, and acceleration is a derivative of the speed↩︎",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Flappy Bird</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html",
    "href": "10-guitar-hero.html",
    "title": "10  Guitar Hero",
    "section": "",
    "text": "10.1 Chapter concepts",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#chapter-concepts",
    "href": "10-guitar-hero.html#chapter-concepts",
    "title": "10  Guitar Hero",
    "section": "",
    "text": "Staircase procedure\nIterator / Generator functions\nSpecial class methods",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#getting-the-difficulty-just-right-staircase-procedure",
    "href": "10-guitar-hero.html#getting-the-difficulty-just-right-staircase-procedure",
    "title": "10  Guitar Hero",
    "section": "10.2 Getting the difficulty just right: Staircase procedure",
    "text": "10.2 Getting the difficulty just right: Staircase procedure\nIn game design, one of the hardest things to get right is difficulty. Make your game too easy and it will be boring. Make it too hard and only hardcore fans will play and only for an achievement. Thus, you would like to make your game hard enough to push a player to the limit but not much harder than that, so not to frustrate them. One way to solve this conundrum is to create different preset difficulty levels. An alternative way is to make a game that adapts its difficulty to the player.\nThe same is true for psychophysical experiments. You want to test ability of your participants to perform a certain task at their limit for one simple reason: At this threshold point influence of any additional factor, whether positive or negative, is most pronounced. For example, use an unusual stimulus configuration or increase attentional load and performance will probably drop. Allow to preallocate attention via cuing or use a prime that is congruent with a target and performance is likely to improve. Of course, these manipulations will have the same overall effect also when the task is particularly easy or maddeningly hard but it will much more difficult to measure this effect. It is one thing if performance drops from 75% to 65% than if it goes from 98% to 95% or from 53% to 52%1 or vice versa. The silliest thing you can do is to hope that performance will allow you too see the effect of the factors that you manipulated. In things like these, knowledge and careful design is definitely superior to hope.\nThus, you want performance of your participants to be approximately in the middle between the ceiling (100% performance, fastest response times, super easy) and the floor (chance level performance, slowest response times, super hard or even impossible). But how do you know where this magic point for a particular person is? Particularly, if the task is novel so you have little information to guide you2. The solution is to adjust the difficulty on-the-fly based on participant’s responses. For example, if you have a two-alternatives-forced-choice task, you can use a two-up-one-down staircase (difficulty increases after two correct responses and decreases after one mistake) that targets 70.7% performance threshold. There are different methods and even different ways to use the same core method (e.g., does the step stays constant or changes, what is the run termination criteria, etc.), so it is always a good idea to refresh your memory and read about adaptive procedures when designing your next experiment.\nIn our game, we will use a very simple 3-up-1-down staircase: get the three responses correct on a row and things get faster, make a mistake and the game slows down. We’ll see how fast you can go! First, you will implement it by hand and then we will use its PsychoPy implementation.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#guitar-hero",
    "href": "10-guitar-hero.html#guitar-hero",
    "title": "10  Guitar Hero",
    "section": "10.3 Guitar Hero",
    "text": "10.3 Guitar Hero\nToday, we will program Guitar Hero game. In the original game, you must play notes on a guitar-shaped controller pressing buttons at the right time, just like when you actually play music on a guitar. On the one hand, it is a straightforward and repetitive motor task. On the other hand, take a fast and complicated music piece and it’ll take many minutes or even hours of practice to get it right. It is a lot of fun, as music cues and primes your responses. The same idea of music-synchronized-actions was used in Raymon Legends music levels where jumps and hits are timed to drums or bass. It is a bizarrely cool dance-like sequence and a very satisfying experience, also when watching pros to do it (I happened to have couple in my household).\nWe will program this game (sans Guitar and Hero) and you can see it in the video below. The player must press a correct key (left, down, or right) whenever the target crosses the line. Pressing it to early or too late counts as a mistake. Of course, the faster the targets go, the harder it is to respond on time and with a correct key. As I wrote above, we will use the 3-up-1-down staircase procedure to control for that.\n\nAs per usual, we will take a gradual approach:\n\nBoilerplate code\nCreate a class for individual moving targets\nCreate a timed-response task class that will create them (using cool generators), dispose of them, check the response, and adjust staircase.\nAdd bells-and-whistles like score and time limited runs.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#boilerplate",
    "href": "10-guitar-hero.html#boilerplate",
    "title": "10  Guitar Hero",
    "section": "10.4 Boilerplate",
    "text": "10.4 Boilerplate\nCreate our usual boilerplate code in code01.py:\n\nCreate file with basic settings (e.g., window size, I’ve picked 640×480 but choose whatever looks good on your screen) to which you can add later on.\nImport what is needed from PsychoPy.\nCreate a window.\nCreate our usual main game loop with gamover variable, flipping the window, and checking for escape button press.\n\n\nPut your boilerplate code into code01.py.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#target-and-timedresponsetask-classes",
    "href": "10-guitar-hero.html#target-and-timedresponsetask-classes",
    "title": "10  Guitar Hero",
    "section": "10.5 Target and TimedResponseTask classes",
    "text": "10.5 Target and TimedResponseTask classes\nOur main work horse will be TimedResponseTask class. It will spawn a new random Target at random intervals (which will depend on speed), pass speed information to moving targets, and remove targets, once they disappear below the screen. The Target class will inherit from visual.rect.Rect class with some extra bells and whistles to make it appear at the right location, move at the right speed, change its line color (indicating a correct response), compute whether it is already off the screen, etc. We will start with a single target first.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#target-class-a-static-target",
    "href": "10-guitar-hero.html#target-class-a-static-target",
    "title": "10  Guitar Hero",
    "section": "10.6 Target class: a static target",
    "text": "10.6 Target class: a static target\nFirst, create a Target class: a colored rectangle in one of the three positions that starts at the top of the window and moves down at a specific speed. Its constructor should take PsychoPy window as a parameter (you will need it to create the rectangle), position index (ipos, from 0 to 2), speed (speed, in \"norm\" units per second), and common settings (settings, a dictionary with target-specific settings from our settings file) . The only thing we need to do right now in the constructor is use the constructor of the ancestor Rect() class via super().__init__(...) call, similar to how you initialized an the FlappyBird class. Think of which parameters you need to pass, as you need to think about rectangle’s position, size, and color. Store both ipos and speed as attributes for later use. In addition, define a score attribute and set it to None. This will hold the score the participant got for this target and None means that it has not been responded upon yet.\nThe second parameter — position index — determines the horizontal position of the target and its color (to make targets more fun and distinct). For my code, I have decided to make rectangle 0.4 norm units wide and 0.1 norm units high. The leftmost red rectangle (for ipos 0), is centered at -0.5, the middle green one is dead center, and the rightmost blue rectangle is centered at 0.5. I’ve defined all these in my settings.json file under Target group. Think about how you can compute both color and position for a target from ipos and settings without using if-else statements. Also, think about the y-position of the rectangle, so it appears right at the top of the window.\nTest it by creating a target at one of the position (or three targets at all three positions) and drawing them in the main loop. You should get nice looking but static rectangle(s).\n\nPut updated code in code02.py and create the class Target in a separate file.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#target-class-a-moving-target",
    "href": "10-guitar-hero.html#target-class-a-moving-target",
    "title": "10  Guitar Hero",
    "section": "10.7 Target class: a moving target",
    "text": "10.7 Target class: a moving target\nOur targets fall down at speed defined by their speed attribute. Later on, we will change that attribute dynamically to speed up or slow down their fall.\nFor the actual falling down, implement a new method, call it fall(), that will update target’s position on every frame. The speed is in norm units per second, thus, to compute the change in vertical position you also need to know the how much time in seconds has elapsed since last position update. The simplest way to do this is by using a Clock class. You create it as an attribute in the constructor and then, in the fall() method you use its current time to compute and apply a change in vertical position of the rectangle. Don’t forget to reset the clock after that! (Same logic as for the Flappy Bird you already programmed.)\nInclude fall() method call in the main loop and see how the target falls. Experiment with falling speed!\n\nPut updated code in code03.py and update the class Target.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#iteratorgenerator-functions",
    "href": "10-guitar-hero.html#iteratorgenerator-functions",
    "title": "10  Guitar Hero",
    "section": "10.8 Iterator/Generator functions",
    "text": "10.8 Iterator/Generator functions\nIn the next section, we will create a TimedResponseTask class that will generate targets at a random location and after a random interval. We can, of course, do it directly in the class but where’s fun in that?! Instead, we will use this as an opportunity to learn about iterator/generator functions. An iterator is a function that uses yield instead of return statement to, well, yield a value. It yields it, because the function itself returns an iterator object that you can iterate over in a for loop or via next() function. Importantly, yield “freezes” execution of the function and the next time you call the function it continues from that point rather than from the start of the function. Once you reach the end of the function, it automatically raises StopIteration() exception, so you don’t need to worry about how to communicate that you ran out of items. It may sound confusing but it is really simple. Here an example to illustrate this:\n\ndef iterator_fun():\n    yield 3\n    yield 1\n    yield \"wow!\"\n  \n# function returns an iterator, not a value!\nprint(iterator_fun())\n\n&lt;generator object iterator_fun at 0x0000021DD9609590&gt;\n\n\n\n# iterating via for loop\nfor elem in iterator_fun():\n    print(elem)\n\n3\n1\nwow!\n\n\n\n# iterating via next(), note you use an iterator object \n# that function returned, not the function itself!\nan_iterator = iterator_fun()  \n\n# now you can use an_iterator to get a next item from it\nprint(next(an_iterator))\nprint(next(an_iterator))\nprint(next(an_iterator))\n\n3\n1\nwow!\n\n\n\n# next call will raise an exception StopIteration()\nprint(next(iterator_var))\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 2\n      1 # next call will raise an exception StopIteration()\n----&gt; 2 print(next(iterator_var))\n\nNameError: name 'iterator_var' is not defined\n\n\n\nThis format makes writing iterators very easy, just yield whatever you want in an order you want and Python will take care of the rest. You can also yield in a loop, inside an if-else statement, etc. Look at the code below and figure out what will be printed out before running it.\ndef iterator_fun():\n  for e in range(4):\n    if e % 2 == 1:\n      yield e\n\nfor item in iterator_fun():\n  print(item)\nFor our TimedResponseTask class, we will need two generators. They are generators rather than iterators because both will be endless (iterators iterate over finite set of items). One that generates a random delay until the next target and one that generates a random target position (0, 1, or 2). Implement both in a separate file (I called it generators.py).\nThe time_to_next_target_generator() function should take a tuple of two float values, which define shortest and longest allowed delays, as a parameter and yield a random number within this range in an endless loop. We need the endless loop (while True: will do) because we do not know how many values we will need, so we just generate as many as needed on demand.\nThe next_target_generator() will be a bit more interesting. It can just return a random.choice from 0, 1, and 2 but where is fun in that? Instead, we will make it a bit more complicated to ensure that all three targets appear equal number of times within 3N trials, where N will be a parameter of the generator function. This would ensure random, reasonably unpredictable but balanced targets in the short run. Remember, in the long run random choice will always give us a balanced uniform distribution but there is not such guarantee for the shorter runs of a few trials. First, you should create a list where each target appears N times (think how you can do it using range(), list() and *). Then, create an endless loop (again, we don’t know how many values we will need) in which you 1) shuffle elements of the list, 2) yield one element at a time via for loop. Once you run out of elements, you shuffle them again and yield one by one again. Then repeat. And again, and again. Endless loop!\nI would suggest creating and testing both function in a Jupyter notebook first and then putting them in a separate file (e.g., generators.py). Be careful if you decide to use a for loop instead of next() for testing. Remember, both a generators and will never run out of items to yield for a for loop!\n\nPut both generators into generators.py.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#timedresponsetask-class",
    "href": "10-guitar-hero.html#timedresponsetask-class",
    "title": "10  Guitar Hero",
    "section": "10.9 TimedResponseTask class",
    "text": "10.9 TimedResponseTask class\nNow we are ready to create the TimedResponseTask class. For our first take, it will create targets at a random location (next_target_generator()) after a random interval (time_to_next_target_generator()) plus take care of moving and drawing all of them. More bells and whistles (disposing of targets that went past the screen, changing the speed, checking response validity, etc.) will come later.\nFor the constructor, we definitely need PsychoPy window as a parameter, because we need it every time we create a new target. In addition, we need to pass a dictionary with settings for the task (initial speed, a tuple with range for time intervals between targets for time_to_next_target_generator(), and number of target repetitions for the next_target_generator()) and a dictionary with settings for the Target class (we need it every time we create a new target). We will use these parameters beyond the constructor, so save them as attributes. Plus, create an attribute targets and initialize it to an empty list (we will store Target objects in it), and create attributes for both generator objects using the appropriate parameters. Also create a speed_factor attribute and set it to 1. We will use it later to control both the speed of motion and how frequently the targets are generated. The higher is the factor, the faster targets move and the shorter is the interval to the target and vice versa. Finally, we need a Clock3 that will count the time to the moment when we need to generate a new target (new_target_timer) and an attribute that will hold that time (time_till_next_target). Initialize the latter to the next() item from time-to-next-target generator (remember, you need to use the attribute, which is a generator object that function returned, not the function itself).\nNow we need to add three methods draw, update, and add_next_target. The first one is easy, it simply draws all targets in a for loop. The second is also easy, it makes all targets fall plus, after the loop, it should call add_next_target method. The add_next_target method should check whether the elapsed time for new_target_timer times the speed_factor (as the speed increases, the time to the next target goes faster) has exceeded the time_till_next_target (this modulation of elapsed time due to speed is why we can’t easily use a CountdownTimer instead). If that is indeed the case, create a new random target (get the next() position from the position generator and remember to pass speed times speed_factor!), add it to the list of targets, reset the timer and get new time_till_next_target using next() item from the time generator.\nIn the main file, create TimedResponsTask object (use a name you like) and call its draw and update methods in the main loop. You should see targets appearing at random and falling down consistently.\n\nPut updated code in code04.py and create the class TimedResponseTask.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#disposing-of-targets",
    "href": "10-guitar-hero.html#disposing-of-targets",
    "title": "10  Guitar Hero",
    "section": "10.10 Disposing of targets",
    "text": "10.10 Disposing of targets\nCurrently, our targets keep falling down even when they are below the screen. This will not affect the performance immediately but it will be taxing both memory and CPU, so we should dispose of them. In the Target class, create a new read-only (computed) @property called is_below_the_screen that returns True if the upper edge of the target is below the lower edge of the screen, False otherwise, of course, and you definitely do not need if-else!\nNext, in the update method of TimedResponseTask, add a second loop (or modify the existing loop) where you delete any object that is_below_the_screen.\nFor debugging, run the main code, wait until at least one target falls below the screen, put a break point and check targets attribute. Its length should match the number of visible targets, not of the total generated targets.\n\nUpdate classes Target and TimedResponseTask.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#finishing-line",
    "href": "10-guitar-hero.html#finishing-line",
    "title": "10  Guitar Hero",
    "section": "10.11 Finishing line",
    "text": "10.11 Finishing line\nAdd a new visual attribute to the TimedResponseTask that is a horizontal line. The task of the player will be to press a corresponding key whenever a target crosses (overlaps with) the line. For now, create it as an attribute in the constructor (pick the vertical location you like) and draw it inside the draw() method.\n\nUpdate class TimedResponseTask.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#response",
    "href": "10-guitar-hero.html#response",
    "title": "10  Guitar Hero",
    "section": "10.12 Response",
    "text": "10.12 Response\nNow the real fun begins! We will allow a player to press keys and check whether a corresponding target is on the line. For this, we need new methods for both Target and TimedResponseTask classes. For the Target, implement a new method class overlaps() that will take a vertical position (of the finishing line) as the only float number parameter. In the method, first you check that the score attribute is None. If it not None that means that the player already responded on to the target and they are not allowed to respond to it twice. If it is None, compute a score using the following formula: \\[score = int \\left(10 - 10 \\cdot \\frac{|y_{target} - y_{line}|}{h_{target} / 2} \\right)\\] where \\(y_{target}\\) is the vertical center of the target, \\(y_{line}\\) is the vertical position of the line (you get it as a function parameter), \\(h_{target}\\) is height of the target, \\(|x|\\) means absolute value of \\(x\\) (use fabs function from math library for that), and 10 is an arbitrary scaling factor (you can use any integer and put it into settings). Study the formula and you will see that score is 10 if the target’s center is right on the line but decreases linearly with any displacement for both early (target’s center is above the line) or late (target’s center is already below the line) responses. Once the target is off the line, the score becomes negative. We convert it to int, because we want simple scores (floats look messy for this). Compute the score and store in a temporary local variable. If the value is positive, that means success, so you should store this value permanently in the score attribute, change line color of the rectangle to white (to show the player that they got it right), and return True (yes, target does overlap with the line!). For all other outcomes, you return False. This means that either the response was already made or the target does not overlap with the line at the time of the key press.\nIn the TimerResponseTask class, we need a new method check() that will take position of the target based on the key press (so if a player pressed left key, the position will be \\(0\\), down is \\(1\\), and right is \\(2\\)). Loop over targets and if target’s position (ipos attribute) matches the position of the key press (parameter of the function) and target overlaps with the line (the overlaps() method returns True), return the score attribute of that target. Note that the condition order is important here! You need to check for the overlap only if target position matches the key. If you ran out of targets to check that means that the player pressed a wrong key or at the wrong time, so you should return 0 (means “mistake”).\nIn the main loop, add \"left\", \"down\", and \"right\" to the key list of getKeys() call. Then, if any of these three keys are pressed, translate that into a position, respectively, 0, 1, and 2 (think how you can do it without if-else via a dictionary), and call the new check method of the TimedResponseClass. Test the code, targets’ edges should turn white, if you time your key press correctly!\n\nPut updated code in code05.py, update Target and TimedResponseTask classes.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#score",
    "href": "10-guitar-hero.html#score",
    "title": "10  Guitar Hero",
    "section": "10.13 Score",
    "text": "10.13 Score\nPlaying is more fun when you can see how well you are doing. Let us add a simple score indicator that is updated with response score. You already know how you can do it via TextStim stimulus but you also already know how you can inherit from a base class and extend its functionality. This is what we will do here, as the class will record and draw the score (that part is covered by the inheritance).\nCreate a new class (I have called it ScoreText) that inherits from TextStim. In the constructor, you need to create an integer attribute that will hold current score and initialize it 0. Plus, call ancestor’s constructor via super().__init__(...) to initialize and place the text stimulus (I’ve picked top left corner). Think about parameters that the constructor and ancestor’s constructor need.\nNext, we need to update the score (both its numeric form and the text that we draw) every time participant presses a key. We could implement the code outside of the class but that is a fairly bad idea, as it puts class-related code elsewhere. We could also implement a “normal” method, e.g., add() that will take care of that. Instead, we will implement a special method iadd that allows to “add to” the object. It takes a single parameter (in addition to the compulsory self, of course), performs “adding to the self” operation (whatever that means with respect to your object, can be mathematical addition for an attribute, concatenation of the string, adding to the list, etc.), and returns back the reference to itself, i.e., returns self not a value of any attribute! Here’s how it works:\n\nclass AddIt():\n    def __init__(self):\n        self.number = 0\n        \n    def __iadd__(self, addendum):\n        self.number += addendum\n        return self # important!!!\n\n\nadder = AddIt()\nprint(adder.number)\n\n0\n\n\n\nadder += 10\nprint(adder.number)\n\n10\n\n\nImplement that special method for your class, so we can do score_stim +=  timed_task.check(...). Remember, you have to update both numeric and visual representations of the score in that method! Add the score to the main code.\n\nPut updated code in code06.py, create ScoreText class.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#staircase",
    "href": "10-guitar-hero.html#staircase",
    "title": "10  Guitar Hero",
    "section": "10.14 Staircase",
    "text": "10.14 Staircase\nWe will implement the staircase as part of the TimerResponseTask class, so it can speed up and slow down itself. For this, we will need an attribute that counts number of consecutive correct responses (I, typically, call it correct_in_a_row or something like that). Create and initialize it to zero in the constructor.\nNext, create a new method staircase() that will take a single parameter (beyond self) on whether the response was correct or not. If it was, increment correct_in_a_row by one and check whether it reached 3. If it did, increase the speed_factor by multiplying it by some chosen factor (I’ve picked 1.3) and resetting correct_in_a_row to 0. This is equivalent to using a logarithmic step as our speed_factor is adjusted as a fraction of its magnitude. Alternatively, if the response was not correct, divide speed_factor by the same number (e.g., 1.3, so slowing things down) and again, reset correct_in_a_row to 0. After that, loop over all targets and update their speed based on speed and speed_factor attributes.\nYou need to call this method inside the check method, think then and how.\n\nUpdate TimedTaskResponse class.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#limiting-time",
    "href": "10-guitar-hero.html#limiting-time",
    "title": "10  Guitar Hero",
    "section": "10.15 Limiting time",
    "text": "10.15 Limiting time\nLet us add a competitive edge by limiting the run time to 20 seconds (you can pick your own duration, of course, and you definitely want to be a setting). Create an additional outer loop, so that the game can be played many times over. Once the round is over, show the latest state (redrawing all game objects) plus the “Round over” sign and wait for the player to press either escape (then you exit the game) or space (to start the next round). Remember to recreate all game objects anew for the next round (or create a reset method for all of them).\n\nPut updated code in code07.py.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#using-psychopys-stairhandler",
    "href": "10-guitar-hero.html#using-psychopys-stairhandler",
    "title": "10  Guitar Hero",
    "section": "10.16 Using PsychoPy’s StairHandler",
    "text": "10.16 Using PsychoPy’s StairHandler\nNow that you know how to program a very basic staircase, let us use its much more flexible implementation by PsychoPy via StairHandler class. We will use it so as to replicate the staircase that we already implemented. However, it is capable of much more and PsychoPy has implementation for other adaptive methods, such as parametric Psi or Quest approaches. I strongly recommend consulting the literature to decide which method is best suited for your experiment and then relying on PsychoPy’s implementation in your code.\nWe will need to modify our TimedResponseTask, so let us create its a twin TimedResponseTask2 (or TimedResponseTaskPsychoPy, if you find that more intuitive). Simply copy-paste the entire code, modify the name, import and use it in your code08.py code. Make sure everything works just as before (because you did not do anything beyond making a carbon copy).\nNow let us make use of the StairHandler in TimedResponseTask2. Drop correct_on_a_row attribute and create a StairHandler as stairhandler attribute instead. You need to specify startVal which is the initial value for the speed_factor, thus use whatever value you had previously. StairHandler uses nUp=1 and nDown=3 by default. This matches our custom staircase, so theoretically you can use defaults by omitting these parameters. However, for the sake of code’s readability, do specify these explicitly. Our steps were logarithmic, so use stepType=\"log\" and a single fixed stepSizes=-0.1. The magnitude of -0.1 correspond roughly to the step that we used in the custom staircase and we need the negative sign because StairHandler increases the staircase level following an incorrect response. In our case, we want an exact opposite, decreasing speed_factor to slow targets down. Hence, the negative sign that turns increase into a decrease. Finally, StairHandler will terminate after it reaches either desired number of trials (nTrial) or reversals (nReversals, changes from correct to incorrect responses or vice versa). These are the settings that would typically determine length of a single block/run in the real experiment. However, we limited our rounds by time, so we only need to make sure that the StairHandler does not run out of trials before the game round is over. Thus, specify some very large number (e.g., 1000) for both these parameters.\nOnce you created stairhandler attribute, it is ready for use via next(self.stairhandler). Call it the first time in the constructor and assign the value it returns to speed_factor attribute (should be whatever startVal you assigned to it but do put a breakpoint and double-check!)\nNext, we need to modify our staicase() method making it much simpler. First, remove the if correct: ... else: ... code but leave targets’ speed adjustment code intact (we still need it!). Then, let stairhandler adjust itself via addResponse() method using an information on whether the response was correct (you already have a parameter with exactly that information). Finally, get the next speed_factor exactly the same way as in the constructor. Done!\n\nPut updated code in code08.py using TimedResponseTask2.\n\nYour program should run very much like before but now you have many more opportunities to make it more flexible at little cost for yourself (look at StairHandler settings) and to log it via one of saveAs methods.Let us do the latter, save staircase logs via saveAsText() after a run is over. Figure out a way to generate a unique filename for each run, so that the logs will not be overwritten.\n\nSave staircase logs in code09.py.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#this-is-just-a-start",
    "href": "10-guitar-hero.html#this-is-just-a-start",
    "title": "10  Guitar Hero",
    "section": "10.17 This is just a start!",
    "text": "10.17 This is just a start!\nAs per usual, think about how you can extend the game. A clock showing the remaining time is definitely missing. Auditory feedback would be nice. More positions? Random colors to confuse a player?",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "10-guitar-hero.html#footnotes",
    "href": "10-guitar-hero.html#footnotes",
    "title": "10  Guitar Hero",
    "section": "",
    "text": "Here, I assume that 50% is chance level performance.↩︎\nIt is the usual paradox that in order to optimally measure a threshold condition for a particular task, you should measure at or around the threshold. But if you already know where to measure, you don’t need to measure.↩︎\nWhy not the CountdownTimer? Because as you will see below, we count the time given the speed factor, so we can “speed up” the clock, something which is a bit harder to implement for the timer.↩︎",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Guitar Hero</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Concepts\nClasses And Objects, Using\nLink within the book\n\n\n\nConditions And Comparisons\nLink within the book\n\n\n\nConstants\nLink within the book\n\n\n\nDebugging\nLink within the book\nLink to documentation\n\n\nDocumenting Code\nLink within the book\nLink to documentation\n\n\nFunction Arguments By Position Or Name\nLink within the book\nLink to documentation\n\n\nFunctions\nLink within the book\n\n\n\nHashable Values\nLink within the book\nLink to documentation\n\n\nIndentation\nLink within the book\n\n\n\nLibraries\nLink within the book\n\n\n\nList\nLink within the book\nLink to documentation\n\n\nList Operations\nLink within the book\n\n\n\nMutable Objects\nLink within the book\n\n\n\nNumpy Docstring\nLink within the book\nLink to documentation\n\n\nSlicing\nLink within the book\nLink to documentation\n\n\nString Formatting\nLink within the book\nLink to documentation\n\n\nValue Types\nLink within the book\nLink to documentation\n\n\nVariable Scopes For Immutable Values\nLink within the book\n\n\n\nVariables\nLink within the book",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "references.html#functions-and-statements",
    "href": "references.html#functions-and-statements",
    "title": "References",
    "section": "Functions and statements",
    "text": "Functions and statements\n\n\n\n\n\nAugmented assignment statements\nLink within the book\nLink to documentation\n\n\nbool()\nLink within the book\nLink to documentation\n\n\nbreak\nLink within the book\nLink to documentation\n\n\nDictionary\nLink within the book\nLink to documentation\n\n\nenumerate()\nLink within the book\nLink to documentation\n\n\nfloat()\nLink within the book\nLink to documentation\n\n\nfor loop\nLink within the book\nLink to documentation\n\n\nif-elif-else\nLink within the book\nLink to documentation\n\n\nin\nLink within the book\nLink to documentation\n\n\ninput()\nLink within the book\nLink to documentation\n\n\nint()\nLink within the book\nLink to documentation\n\n\nlen()\nLink within the book\nLink to documentation\n\n\nList comprehension\nLink within the book\nLink to documentation\n\n\nlist methods\nLink within the book\nLink to documentation\n\n\nlist, unpacking arguments\nLink within the book\nLink to documentation\n\n\nlist.clear()\nLink within the book\nLink to documentation\n\n\nlist.extend()\nLink within the book\nLink to documentation\n\n\nlist.index(value)\nLink within the book\nLink to documentation\n\n\nos library\nLink within the book\nLink to documentation\n\n\nos.listdir(path=“.”)\nLink within the book\nLink to documentation\n\n\nos.path.join()\nLink within the book\nLink to documentation\n\n\nprint()\nLink within the book\nLink to documentation\n\n\nrandom.choice()\nLink within the book\nLink to documentation\n\n\nrandom.randint()\nLink within the book\nLink to documentation\n\n\nrandom.randrange()\nLink within the book\nLink to documentation\n\n\nrandom.shuffle()\nLink within the book\nLink to documentation\n\n\nrandom.uniform()\nLink within the book\nLink to documentation\n\n\nrange()\nLink within the book\nLink to documentation\n\n\nround()\nLink within the book\nLink to documentation\n\n\nstr()\nLink within the book\nLink to documentation\n\n\nstr.startswith()\nLink within the book\nLink to documentation\n\n\ntuple()\nLink within the book\nLink to documentation\n\n\nwhile loop\nLink within the book\nLink to documentation",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "references.html#psychopy",
    "href": "references.html#psychopy",
    "title": "References",
    "section": "PsychoPy",
    "text": "PsychoPy\n\n\n\n\n\nAPI documentation\nLink within the book\nLink to documentation\n\n\nclock.Clock\nLink within the book\nLink to documentation\n\n\nclock.CountdownTimer\nLink within the book\nLink to documentation\n\n\nclock.wait()\nLink within the book\nLink to documentation\n\n\nevent.waitKeys()\nLink within the book\nLink to documentation\n\n\nMouse\nLink within the book\nLink to documentation\n\n\nMouse.getPos()\nLink within the book\nLink to documentation\n\n\nMouse.getPressed()\nLink within the book\nLink to documentation\n\n\nUnits for the window and stimuli\nLink within the book\nLink to documentation\n\n\nvisual.circle.Circle\nLink within the book\nLink to documentation\n\n\nvisual.ImageStm\nLink within the book\nLink to documentation\n\n\nvisual.rect.Rect\nLink within the book\nLink to documentation\n\n\nvisual.TextStim\nLink within the book\nLink to documentation\n\n\nWindow\nLink within the book\nLink to documentation\n\n\nWindow.close()\nLink within the book\nLink to documentation\n\n\nWindow.flip()\nLink within the book\nLink to documentation",
    "crumbs": [
      "References"
    ]
  }
]